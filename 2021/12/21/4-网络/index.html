<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"sk-xinye.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.yml"};
  </script>

  <meta name="description" content="网络相关概念网络模型  Linux 网络栈   传输层在应用程序数据前面增加了 TCP 头； 网络层在 TCP 数据包前增加了 IP 头； 而网络接口层，又在 IP 数据包前后分别增加了帧头和帧尾。     最上层的应用程序，需要通过系统调用，来跟套接字接口进行交互； 套接字的下面，就是我们前面提到的传输层、网络层和网络接口层； 最底层，则是网卡驱动程序以及物理网卡设备。  这里我简单说一下网卡。">
<meta property="og:type" content="article">
<meta property="og:title" content="4.网络">
<meta property="og:url" content="https://sk-xinye.github.io/2021/12/21/4-%E7%BD%91%E7%BB%9C/index.html">
<meta property="og:site_name" content="sk-xinyeの博客">
<meta property="og:description" content="网络相关概念网络模型  Linux 网络栈   传输层在应用程序数据前面增加了 TCP 头； 网络层在 TCP 数据包前增加了 IP 头； 而网络接口层，又在 IP 数据包前后分别增加了帧头和帧尾。     最上层的应用程序，需要通过系统调用，来跟套接字接口进行交互； 套接字的下面，就是我们前面提到的传输层、网络层和网络接口层； 最底层，则是网卡驱动程序以及物理网卡设备。  这里我简单说一下网卡。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://sk-xinye.github.io/2021/12/21/4-%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.webp">
<meta property="og:image" content="https://sk-xinye.github.io/2021/12/21/4-%E7%BD%91%E7%BB%9C/linux%E7%BD%91%E7%BB%9C.webp">
<meta property="og:image" content="https://sk-xinye.github.io/2021/12/21/4-%E7%BD%91%E7%BB%9C/linux%E7%BD%91%E7%BB%9C%E6%A0%88.webp">
<meta property="og:image" content="https://sk-xinye.github.io/2021/12/21/4-%E7%BD%91%E7%BB%9C/linux%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91.webp">
<meta property="og:image" content="https://sk-xinye.github.io/2021/12/21/4-%E7%BD%91%E7%BB%9C/%E4%B8%80%E4%B8%BB%E5%A4%9A%E4%BB%8E%E6%A8%A1%E5%9E%8B.webp">
<meta property="og:image" content="https://sk-xinye.github.io/2021/12/21/4-%E7%BD%91%E7%BB%9C/%E5%A4%9A%E4%B8%BB%E6%A8%A1%E5%9E%8B.webp">
<meta property="og:image" content="https://sk-xinye.github.io/2021/12/21/4-%E7%BD%91%E7%BB%9C/tcpdump%E9%80%89%E9%A1%B9.webp">
<meta property="og:image" content="https://sk-xinye.github.io/2021/12/21/4-%E7%BD%91%E7%BB%9C/tcpdump%E8%BF%87%E6%BB%A4%E8%A1%A8%E8%BE%BE%E5%BC%8F.webp">
<meta property="og:image" content="https://sk-xinye.github.io/2021/12/21/4-%E7%BD%91%E7%BB%9C/%E6%AD%A3%E5%B8%B8%E5%8C%85.webp">
<meta property="og:image" content="https://sk-xinye.github.io/2021/12/21/4-%E7%BD%91%E7%BB%9C/%E6%8C%87%E6%A0%87%E6%89%BE%E5%B7%A5%E5%85%B7.webp">
<meta property="og:image" content="https://sk-xinye.github.io/2021/12/21/4-%E7%BD%91%E7%BB%9C/%E5%B7%A5%E5%85%B7%E6%8C%87%E6%A0%87.webp">
<meta property="article:published_time" content="2021-12-21T02:19:51.000Z">
<meta property="article:modified_time" content="2023-02-04T02:33:07.930Z">
<meta property="article:author" content="sk-xinye">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sk-xinye.github.io/2021/12/21/4-%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.webp">

<link rel="canonical" href="https://sk-xinye.github.io/2021/12/21/4-%E7%BD%91%E7%BB%9C/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>4.网络 | sk-xinyeの博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">sk-xinyeの博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录学习的脚步</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-fa fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">1</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">18</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">142</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sk-xinye.github.io/2021/12/21/4-%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sk-xinye">
      <meta itemprop="description" content="愿所有努力都不被辜负">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sk-xinyeの博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          4.网络
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-21 10:19:51" itemprop="dateCreated datePublished" datetime="2021-12-21T10:19:51+08:00">2021-12-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-04 10:33:07" itemprop="dateModified" datetime="2023-02-04T10:33:07+08:00">2023-02-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="网络相关概念"><a href="#网络相关概念" class="headerlink" title="网络相关概念"></a>网络相关概念</h2><h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><img src="/2021/12/21/4-%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.webp" class="">

<h3 id="Linux-网络栈"><a href="#Linux-网络栈" class="headerlink" title="Linux 网络栈"></a>Linux 网络栈</h3><img src="/2021/12/21/4-%E7%BD%91%E7%BB%9C/linux%E7%BD%91%E7%BB%9C.webp" class="">

<ul>
<li>传输层在应用程序数据前面增加了 TCP 头；</li>
<li>网络层在 TCP 数据包前增加了 IP 头；</li>
<li>而网络接口层，又在 IP 数据包前后分别增加了帧头和帧尾。</li>
</ul>
<img src="/2021/12/21/4-%E7%BD%91%E7%BB%9C/linux%E7%BD%91%E7%BB%9C%E6%A0%88.webp" class="">

<ul>
<li>最上层的应用程序，需要通过系统调用，来跟套接字接口进行交互；</li>
<li>套接字的下面，就是我们前面提到的传输层、网络层和网络接口层；</li>
<li>最底层，则是网卡驱动程序以及物理网卡设备。</li>
</ul>
<p>这里我简单说一下网卡。网卡是发送和接收网络包的基本设备。在系统启动过程中，网卡通过内核中的网卡驱动程序注册到系统中。而在网络收发过程中，内核通过中断跟网卡进行交互。</p>
<h3 id="Linux-网络收发流程"><a href="#Linux-网络收发流程" class="headerlink" title="Linux 网络收发流程"></a>Linux 网络收发流程</h3><img src="/2021/12/21/4-%E7%BD%91%E7%BB%9C/linux%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91.webp" class="">

<ul>
<li>当一个网络帧到达网卡后，网卡会通过 DMA 方式，把这个网络包放到收包队列中；</li>
<li>然后通过硬中断，告诉中断处理程序已经收到了网络包。</li>
<li>网卡中断处理程序会为网络帧分配内核数据结构（sk_buff），并将其拷贝到 sk_buff 缓冲区中；</li>
<li>然后再通过软中断，通知内核收到了新的网络帧。</li>
<li>在链路层检查报文的合法性，找出上层协议的类型（比如 IPv4 还是 IPv6），再去掉帧头、帧尾，然后交给网络层。</li>
<li>网络层取出 IP 头，判断网络包下一步的走向，比如是交给上层处理还是转发。当网络层确认这个包是要发送到本机后，就会取出上层协议的类型（比如 TCP 还是 UDP），去掉 IP 头，再交给传输层处理。</li>
<li>传输层取出 TCP 头或者 UDP 头后，根据 &lt; 源 IP、源端口、目的 IP、目的端口 &gt; 四元组作为标识，找出对应的 Socket，并把数据拷贝到 Socket 的接收缓存中。</li>
<li>应用程序就可以使用 Socket 接口，读取到新接收到的数据了</li>
</ul>
<h3 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h3><ul>
<li>服务端首先创建socket文件，然后bind监听，最后listen()</li>
<li>客户端创建socket文件，connect() 开始与服务端进行3次连接</li>
<li>3次握手涉及到2个队列，未完成连接队列（接收到syn 还未得到客户端确认），已连接队列（接收到了客户端的确认）</li>
<li>应用程序通过accept()从已连接队列中拿到连接的socket fd，然后生成新的socket fd 返回给客户端用户通信</li>
<li>当使用io多路复用器时（select poll epoll）,就可以同时监听多个文件描述符了,核心就是告诉我们哪些文件描述符可读，哪些文件描述符可写<ul>
<li>select：程序把文件描述符集合交给select的系统调用，select遍历每个文件描述符后返回那些可以操作的文件描述符，然后客户端就可以进行读写了。但文件描述符集合大小有限制为1024个</li>
<li>poll 在文件描述符集合的限制上进行了改进</li>
<li>select和poll都有缺点：每次都要将文件描述符集合从用户态到内核态，并从内核态到用户态，而且内核和用户态都需要遍历文件描述符集合</li>
<li>epoll有点：当数据到达网卡时，会触发中断，正常情况下cpu会把相应的数据复制到内存中，和相关文件描述符进行绑定。epoll在这个基础上做了延伸，epoll首先是在内核中维护了一个红黑树，以及一些链表结构，当数据到达网卡拷贝到内存时会把相应的文件描述符从红黑树中拷贝到链表中，这样链表存储的就是已经到达数据的文件描述符，这样当程序调用epoll_wait的时候就能直接把能读的文件描述符返回给应用程序</li>
<li>除了epoll_wait外，epoll还有两个系统调用，分别是epoll_create 和epoll_ctl（这里需要将文件描述符拷贝到内核态）。分别用于初始化epoll和把文件描述符添加到红黑树中</li>
<li>java中selector就是对select、poll、epoll的封装</li>
</ul>
</li>
</ul>
<h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><ul>
<li>带宽，表示链路的最大传输速率，单位通常为 b/s （比特 / 秒）。</li>
<li>吞吐量，表示单位时间内成功传输的数据量，单位通常为 b/s（比特 / 秒）或者 B/s（字节 / 秒）。吞吐量受带宽限制，而吞吐量 / 带宽，也就是该网络的使用率。</li>
<li>延时，表示从网络请求发出后，一直到收到远端响应，所需要的时间延迟。在不同场景中，这一指标可能会有不同含义。比如，它可以表示，建立连接需要的时间（比如 TCP 握手延时），或一个数据包往返所需的时间（比如 RTT）。</li>
<li>PPS，是 Packet Per Second（包 / 秒）的缩写，表示以网络包为单位的传输速率。PPS 通常用来评估网络的转发能力，比如硬件交换机，通常可以达到线性转发（即 PPS 可以达到或者接近理论最大值）。而基于 Linux 服务器的转发，则容易受网络包大小的影响。</li>
<li>除了以上指标还包括网络的可用性（网络能否正常通信）、并发连接数（TCP 连接数量）、丢包率（丢包百分比）、重传率（重新传输的网络包比例）等也是常用的性能指标。</li>
<li>对 TCP 或者 Web 服务来说，更多会用并发连接数和每秒请求数（QPS，Query per Second）等指标，它们更能反应实际应用程序的性能。</li>
</ul>
<h3 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h3><h4 id="查看网络配置（ifconfig-ip）"><a href="#查看网络配置（ifconfig-ip）" class="headerlink" title="查看网络配置（ifconfig/ip）"></a>查看网络配置（ifconfig/ip）</h4><p>ifconfig 和 ip 分别属于软件包 net-tools 和 iproute2，iproute2 是 net-tools 的下一代。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ifconfig eth0</span></span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500</span><br><span class="line">      inet 10.240.0.30 netmask 255.240.0.0 broadcast 10.255.255.255</span><br><span class="line">      inet6 fe80::20d:3aff:fe07:cf2a prefixlen 64 scopeid 0x20&lt;link&gt;</span><br><span class="line">      ether 78:0d:3a:07:cf:3a txqueuelen 1000 (Ethernet)</span><br><span class="line">      RX packets 40809142 bytes 9542369803 (9.5 GB)</span><br><span class="line">      RX errors 0 dropped 0 overruns 0 frame 0</span><br><span class="line">      TX packets 32637401 bytes 4815573306 (4.8 GB)</span><br><span class="line">      TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ip -s addr show dev eth0</span></span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000</span><br><span class="line">  link/ether 78:0d:3a:07:cf:3a brd ff:ff:ff:ff:ff:ff</span><br><span class="line">  inet 10.240.0.30/12 brd 10.255.255.255 scope global eth0</span><br><span class="line">      valid_lft forever preferred_lft forever</span><br><span class="line">  inet6 fe80::20d:3aff:fe07:cf2a/64 scope link</span><br><span class="line">      valid_lft forever preferred_lft forever</span><br><span class="line">  RX: bytes packets errors dropped overrun mcast</span><br><span class="line">   9542432350 40809397 0       0       0       193</span><br><span class="line">  TX: bytes packets errors dropped carrier collsns</span><br><span class="line">   4815625265 32637658 0       0       0       0</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>第一，网络接口的状态标志。ifconfig 输出中的 RUNNING ，或 ip 输出中的 LOWER_UP ，都表示物理网络是连通的，即网卡已经连接到了交换机或者路由器中。如果你看不到它们，通常表示网线被拔掉了</li>
<li>第二，MTU 的大小。MTU 默认大小是 1500，根据网络架构的不同（比如是否使用了 VXLAN 等叠加网络），你可能需要调大或者调小 MTU 的数值。</li>
<li>第三，网络接口的 IP 地址、子网以及 MAC 地址。这些都是保障网络功能正常工作所必需的，你需要确保配置正确。</li>
<li>第四，网络收发的字节数、包数、错误数以及丢包情况，特别是 TX 和 RX 部分的 errors、dropped、overruns、carrier 以及 collisions 等指标不为 0 时，通常表示出现了网络 I/O 问题。其中：<ul>
<li>errors 表示发生错误的数据包数，比如校验错误、帧同步错误等；</li>
<li>dropped 表示丢弃的数据包数，即数据包已经收到了 Ring Buffer，但因为内存不足等原因丢包；</li>
<li>overruns 表示超限数据包数，即网络 I/O 速度过快，导致 Ring Buffer 中的数据包来不及处理（队列满）而导致的丢包；</li>
<li>carrier 表示发生 carrirer 错误的数据包数，比如双工模式不匹配、物理电缆出现问题等；</li>
<li>collisions 表示碰撞数据包数。</li>
</ul>
</li>
</ul>
<h4 id="套接字信息"><a href="#套接字信息" class="headerlink" title="套接字信息"></a>套接字信息</h4><p>你可以用 netstat 或者 ss（推荐） ，来查看套接字、网络栈、网络接口以及路由表的信息。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> head -n 3 表示只显示前面3行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -l 表示只显示监听套接字</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -n 表示显示数字地址和端口(而不是名字)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -p 表示显示进程信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> netstat -nlp | head -n 3</span></span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name</span><br><span class="line">tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN      840/systemd-resolve</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -l 表示只显示监听套接字</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -t 表示只显示 TCP 套接字</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -n 表示显示数字地址和端口(而不是名字)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -p 表示显示进程信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ss -ltnp | head -n 3</span></span><br><span class="line">State    Recv-Q    Send-Q        Local Address:Port        Peer Address:Port</span><br><span class="line">LISTEN   0         128           127.0.0.53%lo:53               0.0.0.0:*        users:((&quot;systemd-resolve&quot;,pid=840,fd=13))</span><br><span class="line">LISTEN   0         128                 0.0.0.0:22               0.0.0.0:*        users:((&quot;sshd&quot;,pid=1459,fd=3))</span><br></pre></td></tr></table></figure>

<p>其中，接收队列（Recv-Q）和发送队列（Send-Q）需要你特别关注，它们通常应该是 0。当你发现它们不是 0 时，说明有网络包的堆积发生。</p>
<ul>
<li>当套接字处于连接状态（Established）时，Recv-Q 表示套接字缓冲还没有被应用程序取走的字节数（即接收队列长度）。而 Send-Q 表示还没有被远端主机确认的字节数（即发送队列长度）。</li>
<li>当套接字处于监听状态（Listening）时，Recv-Q 表示全连接队列的长度。而 Send-Q 表示全连接队列的最大长度。</li>
</ul>
<h4 id="协议栈统计信息"><a href="#协议栈统计信息" class="headerlink" title="协议栈统计信息"></a>协议栈统计信息</h4><p>使用 netstat 或 ss ，也可以查看协议栈的信息：</p>
<ul>
<li>ss 只显示已经连接、关闭、孤儿套接字等简要统计</li>
<li>而 netstat 则提供的是更详细的网络协议栈信息。比如，上面 netstat 的输出示例，就展示了 TCP 协议的主动连接、被动连接、失败重试、发送和接收的分段数量等各种信息。</li>
</ul>
<h4 id="网络吞吐和-PPS"><a href="#网络吞吐和-PPS" class="headerlink" title="网络吞吐和 PPS"></a>网络吞吐和 PPS</h4><p>sar 增加 -n 参数就可以查看网络的统计信息，比如网络接口（DEV）、网络接口错误（EDEV）、TCP、UDP、ICMP 等等。执行下面的命令，你就可以得到网络接口统计信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 数字1表示每隔1秒输出一组数据</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sar -n DEV 1</span></span><br><span class="line">Linux 4.15.0-1035 (ubuntu)   01/06/19   _x86_64_  (2 CPU)</span><br><span class="line"></span><br><span class="line">13:21:40        IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil</span><br><span class="line">13:21:41         eth0     18.00     20.00      5.79      4.25      0.00      0.00      0.00      0.00</span><br><span class="line">13:21:41      docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">13:21:41           lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br></pre></td></tr></table></figure>

<ul>
<li>rxpck/s 和 txpck/s 分别是接收和发送的 PPS，单位为包 / 秒。</li>
<li>rxkB/s 和 txkB/s 分别是接收和发送的吞吐量，单位是 KB/ 秒。</li>
<li>rxcmp/s 和 txcmp/s 分别是接收和发送的压缩数据包数，单位是包 / 秒。</li>
<li>%ifutil 是网络接口的使用率，即半双工模式下为 (rxkB/s+txkB/s)/Bandwidth，而全双工模式下为 max(rxkB/s, txkB/s)/Bandwidth。</li>
</ul>
<p>Bandwidth 可以用 ethtool 来查询，它的单位通常是 Gb/s 或者 Mb/s，不过注意这里小写字母 b ，表示比特而不是字节。我们通常提到的千兆网卡、万兆网卡等，单位也都是比特。如下你可以看到，我的 eth0 网卡就是一个千兆网卡：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ethtool eth0 | grep Speed</span></span><br><span class="line">  Speed: 1000Mb/s</span><br></pre></td></tr></table></figure>

<h3 id="连通性和延时"><a href="#连通性和延时" class="headerlink" title="连通性和延时"></a>连通性和延时</h3><p>我们通常使用 ping ，来测试远程主机的连通性和延时，而这基于 ICMP 协议。比如，执行下面的命令，你就可以测试本机到 114.114.114.114 这个 IP 地址的连通性和延时：</p>
<h3 id="CK10"><a href="#CK10" class="headerlink" title="CK10"></a>CK10</h3><h4 id="I-O-模型优化"><a href="#I-O-模型优化" class="headerlink" title="I/O 模型优化"></a>I/O 模型优化</h4><ul>
<li>水平触发（Level Trigger，LT）：只要文件描述符可以非阻塞地执行 I/O ，就会触发通知。也就是说，应用程序可以随时检查文件描述符的状态，然后再根据状态，进行 I/O 操作。</li>
<li>边缘触发（Edge Trigger，ET）：只有在文件描述符的状态发生改变（也就是 I/O 请求达到）时，才发送一次通知。这时候，应用程序需要尽可能多地执行 I/O，直到无法继续读写，才可以停止。如果 I/O 没执行完，或者因为某种原因没来得及处理，那么这次通知也就丢失了。</li>
</ul>
<p>区别：</p>
<ul>
<li>对于水平触发模式，一个事件只要有，就会一直触发；</li>
<li>对于边缘触发模式，只有一个事件从无到有才会触发。</li>
</ul>
<p>这两个词汇来自电学术语，你可以将 fd 上有数据认为是高电平，没有数据认为是低电平，将 fd 可写认为是高电平，fd 不可写认为是低电平。那么水平模式的触发条件是状态处于高电平，而边缘模式的触发条件是新来一次电信号将当前状态变为高电平，即：</p>
<ul>
<li>水平模式的触发条件：1. 低电平 =&gt; 高电平 2. 处于高电平状态</li>
<li>边缘模式的触发条件：1. 低电平 =&gt; 高电平</li>
</ul>
<p>说的有点抽象，以 socket 的读事件为例，对于水平模式，只要 socket 上有未读完的数据，就会一直产生 EPOLLIN 事件；而对于边缘模式，socket 上每新来一次数据就会触发一次，如果上一次触发后，未将 socket 上的数据读完，也不会再触发，除非再新来一次数据。对于 socket 写事件，如果 socket 的 TCP 窗口一直不饱和，会一直触发 EPOLLOUT 事件；而对于边缘模式，只会触发一次，除非 TCP 窗口由不饱和变成饱和再一次变成不饱和，才会再次触发 EPOLLOUT 事件。</p>
<ul>
<li>socket 可读事件水平模式触发条件：1. socket上无数据 =&gt; socket上有数据 2. socket处于有数据状态</li>
<li>socket 可读事件边缘模式触发条件：1. socket上无数据 =&gt; socket上有数据 2. socket又新来一次数据</li>
<li>socket 可写事件水平模式触发条件：1. socket可写   =&gt; socket可写 2. socket不可写 =&gt; socket可写</li>
<li>socket 可写事件边缘模式触发条件：1. socket不可写 =&gt; socket可写</li>
</ul>
<p>I/O 多路复用的方法。这里其实有很多实现方法，我带你来逐个分析一下。</p>
<ul>
<li>第一种，使用非阻塞 I/O 和水平触发通知，比如使用 select 或者 poll。</li>
<li>第二种，使用非阻塞 I/O 和边缘触发通知，比如 epoll。<ul>
<li>epoll 使用红黑树，在内核中管理文件描述符的集合，这样，就不需要应用程序在每次操作时都传入、传出这个集合。</li>
<li>epoll 使用事件驱动的机制，只关注有 I/O 事件发生的文件描述符，不需要轮询扫描整个集合。</li>
</ul>
</li>
<li>第三种，使用异步 I/O（Asynchronous I/O，简称为 AIO）。<ul>
<li>异步 I/O 允许应用程序同时发起很多 I/O 操作，而不用等待这些操作完成。而在 I/O 完成后，系统会用事件通知（比如信号或者回调函数）的方式，告诉应用程序。这时，应用程序才会去查询 I/O 操作的结果。</li>
</ul>
</li>
</ul>
<h4 id="工作模型优化"><a href="#工作模型优化" class="headerlink" title="工作模型优化"></a>工作模型优化</h4><p><strong>第一种</strong>，主进程 + 多个 worker 子进程，这也是最常用的一种模型。</p>
<ul>
<li>主进程执行 bind() + listen() 后，创建多个子进程；</li>
<li>然后，在每个子进程中，都通过 accept() 或 epoll_wait() ，来处理相同的套接字。</li>
</ul>
<p>最常用的反向代理服务器 Nginx 就是这么工作的。它也是由主进程和多个 worker 进程组成。主进程主要用来初始化套接字，并管理子进程的生命周期；而 worker 进程，则负责实际的请求处理。我画了一张图来表示这个关系。</p>
<img src="/2021/12/21/4-%E7%BD%91%E7%BB%9C/%E4%B8%80%E4%B8%BB%E5%A4%9A%E4%BB%8E%E6%A8%A1%E5%9E%8B.webp" class="">

<p>为了避免惊群问题， Nginx 在每个 worker 进程中，都增加一个了全局锁（accept_mutex）。这些 worker 进程需要首先竞争到锁，只有竞争到锁的进程，才会加入到 epoll 中，这样就确保只有一个 worker 子进程被唤醒。</p>
<p><strong>第二种</strong>，监听到相同端口的多进程模型。</p>
<p>在这种方式下，所有的进程都监听相同的接口，并且开启 SO_REUSEPORT 选项，由内核负责将请求负载均衡到这些监听进程中去。这一过程如下图所示。</p>
<img src="/2021/12/21/4-%E7%BD%91%E7%BB%9C/%E5%A4%9A%E4%B8%BB%E6%A8%A1%E5%9E%8B.webp" class="">

<h3 id="C1000K"><a href="#C1000K" class="headerlink" title="C1000K"></a>C1000K</h3><p>从 C10K 到 C100K ，可能只需要增加系统的物理资源就可以满足；但从 C100K 到 C1000K ，就不仅仅是增加物理资源就能解决的问题了。这时，就需要多方面的优化工作了，从硬件的中断处理和网络功能卸载、到网络协议栈的文件描述符数量、连接状态跟踪、缓存队列等内核的优化，再到应用程序的工作模型优化，都是考虑的重点。</p>
<h3 id="C10M"><a href="#C10M" class="headerlink" title="C10M"></a>C10M</h3><p>要实现 C10M ，就不只是增加物理资源，或者优化内核和应用程序可以解决的问题了。这时候，就需要用 XDP 的方式，在内核协议栈之前处理网络包；或者用 DPDK 直接跳过网络协议栈，在用户空间通过轮询的方式直接处理网络包。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="网络基准测试"><a href="#网络基准测试" class="headerlink" title="网络基准测试"></a>网络基准测试</h3><p>根据前面学过的 TCP/IP 协议栈的原理，这个问题应该不难回答。比如：</p>
<ul>
<li>基于 HTTP 或者 HTTPS 的 Web 应用程序，显然属于应用层，需要我们测试 HTTP/HTTPS 的性能；</li>
<li>而对大多数游戏服务器来说，为了支持更大的同时在线人数，通常会基于 TCP 或 UDP ，与客户端进行交互，这时就需要我们测试 TCP/UDP 的性能；</li>
<li>当然，还有一些场景，是把 Linux 作为一个软交换机或者路由器来用的。这种情况下，你更关注网络包的处理能力（即 PPS），重点关注网络层的转发性能。</li>
</ul>
<h4 id="转发性能"><a href="#转发性能" class="headerlink" title="转发性能"></a>转发性能</h4><p>36 hping3</p>
<h4 id="TCP-UDP-性能"><a href="#TCP-UDP-性能" class="headerlink" title="TCP/UDP 性能"></a>TCP/UDP 性能</h4><p>iperf 或者 netperf。iperf 和 netperf 都是最常用的网络性能测试工具，测试 TCP 和 UDP 的吞吐量。它们都以客户端和服务器通信的方式，测试一段时间内的平均吞吐量。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">在目标机器上启动 iperf 服务端：</span><br><span class="line"><span class="meta">#</span><span class="bash"> -s表示启动服务端，-i表示汇报间隔，-p表示监听端口</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iperf3 -s -i 1 -p 10000</span></span><br><span class="line"></span><br><span class="line">在另一台机器上运行 iperf 客户端，运行测试：</span><br><span class="line"><span class="meta">#</span><span class="bash"> -c表示启动客户端，192.168.0.30为目标服务器的IP</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -b表示目标带宽(单位是bits/s)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -t表示测试时间</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -P表示并发数，-p表示目标服务器监听端口</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iperf3 -c 192.168.0.30 -b 1G -t 15 -P 2 -p 10000</span></span><br><span class="line"></span><br><span class="line">稍等一会儿（15 秒）测试结束后，回到目标服务器，查看 iperf 的报告：</span><br><span class="line">[ ID] Interval           Transfer     Bandwidth</span><br><span class="line">...</span><br><span class="line">[SUM]   0.00-15.04  sec  0.00 Bytes  0.00 bits/sec                  sender</span><br><span class="line">[SUM]   0.00-15.04  sec  1.51 GBytes   860 Mbits/sec                  receiver</span><br></pre></td></tr></table></figure>

<h4 id="HTTP-性能"><a href="#HTTP-性能" class="headerlink" title="HTTP 性能"></a>HTTP 性能</h4><p>要测试 HTTP 的性能，也有大量的工具可以使用，比如 ab、webbench 等，都是常用的 HTTP 压力测试工具。其中，ab 是 Apache 自带的 HTTP 压测工具，主要测试 HTTP 服务的每秒请求数、请求延迟、吞吐量以及请求延迟的分布情况等。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Ubuntu</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> apt-get install -y apache2-utils</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> CentOS</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> yum install -y httpd-tools</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -c表示并发请求数为1000，-n表示总的请求数为10000</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ab -c 1000 -n 10000 http://192.168.0.30/</span></span><br><span class="line">...</span><br><span class="line">Server Software:        nginx/1.15.8</span><br><span class="line">Server Hostname:        192.168.0.30</span><br><span class="line">Server Port:            80</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Requests per second:    1078.54 [#/sec] (mean)</span><br><span class="line">Time per request:       927.183 [ms] (mean)</span><br><span class="line">Time per request:       0.927 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          890.00 [Kbytes/sec] received</span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">            min  mean[+/-sd] median   max</span><br><span class="line">Connect:        0   27 152.1      1    1038</span><br><span class="line">Processing:     9  207 843.0     22    9242</span><br><span class="line">Waiting:        8  207 843.0     22    9242</span><br><span class="line">Total:         15  233 857.7     23    9268</span><br><span class="line"></span><br><span class="line">Percentage of the requests served within a certain time (ms)</span><br><span class="line"><span class="meta">50%</span><span class="bash">     23</span></span><br><span class="line"><span class="meta">66%</span><span class="bash">     24</span></span><br><span class="line"><span class="meta">75%</span><span class="bash">     24</span></span><br><span class="line"><span class="meta">80%</span><span class="bash">     26</span></span><br><span class="line"><span class="meta">90%</span><span class="bash">    274</span></span><br><span class="line"><span class="meta">95%</span><span class="bash">   1195</span></span><br><span class="line"><span class="meta">98%</span><span class="bash">   2335</span></span><br><span class="line"><span class="meta">99%</span><span class="bash">   4663</span></span><br><span class="line"><span class="meta">100%</span><span class="bash">   9268 (longest request)</span></span><br></pre></td></tr></table></figure>

<h4 id="应用负载性能"><a href="#应用负载性能" class="headerlink" title="应用负载性能"></a>应用负载性能</h4><p>在应用层，我们关注的是应用程序的并发连接数、每秒请求数、处理延迟、错误数等，可以使用 wrk、JMeter 等工具，模拟用户的负载，得到想要的测试结果。</p>
<h3 id="tcpdump-和-Wireshark"><a href="#tcpdump-和-Wireshark" class="headerlink" title="tcpdump 和 Wireshark"></a>tcpdump 和 Wireshark</h3><h4 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> CentOS</span></span><br><span class="line">yum install -y tcpdump wireshark</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump -nn udp port 53 or host 35.190.27.188</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tcpdump -nn udp port 53 or host 35.190.27.188 -w ping.pcap</span></span><br><span class="line"></span><br><span class="line">-nn ，表示不解析抓包中的域名（即不反向解析）、协议以及端口号。</span><br><span class="line">udp port 53 ，表示只显示 UDP 协议的端口号（包括源端口和目的端口）为 53 的包。</span><br><span class="line">host 35.190.27.188 ，表示只显示 IP 地址（包括源地址和目的地址）为 35.190.27.188 的包。</span><br><span class="line">这两个过滤条件中间的“ or ”，表示或的关系，也就是说，只要满足上面两个条件中的任一个，就可以展示出来。</span><br><span class="line"></span><br><span class="line">sudo tcpdump -Z zshield -X -nn &#x27;net 10.240.241.0/24 and port 18081&#x27; -w packet</span><br></pre></td></tr></table></figure>

<img src="/2021/12/21/4-%E7%BD%91%E7%BB%9C/tcpdump%E9%80%89%E9%A1%B9.webp" class="">
<img src="/2021/12/21/4-%E7%BD%91%E7%BB%9C/tcpdump%E8%BF%87%E6%BB%A4%E8%A1%A8%E8%BE%BE%E5%BC%8F.webp" class="">

<p>tcpdump 输出格式：</p>
<p>时间戳 协议 源地址.源端口 &gt; 目的地址.目的端口 网络包详细信息</p>
<h4 id="wireshark"><a href="#wireshark" class="headerlink" title="wireshark"></a>wireshark</h4><img src="/2021/12/21/4-%E7%BD%91%E7%BB%9C/%E6%AD%A3%E5%B8%B8%E5%8C%85.webp" class="">

<p>点击 Statistics -&gt; Flow Graph，然后，在弹出的界面中的 Flow type 选择 TCP Flows，你可以更清晰的看到，整个过程中 TCP 流的执行过程</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> --tcp表示使用TCP协议，-p表示端口号，-n表示不对结果中的IP地址执行反向域名解析</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> traceroute --tcp -p 80 -n baidu.com</span></span><br><span class="line">traceroute to baidu.com (123.125.115.110), 30 hops max, 60 byte packets</span><br><span class="line"> 1  * * *</span><br><span class="line"> 2  * * *</span><br><span class="line"> 3  * * *</span><br><span class="line"> 4  * * *</span><br><span class="line"> 5  * * *</span><br><span class="line"> 6  * * *</span><br><span class="line"> 7  * * *</span><br><span class="line"> 8  * * *</span><br><span class="line"> 9  * * *</span><br><span class="line">10  * * *</span><br><span class="line">11  * * *</span><br><span class="line">12  * * *</span><br><span class="line">13  * * *</span><br><span class="line">14  123.125.115.110  20.684 ms *  20.798 ms</span><br></pre></td></tr></table></figure>

<p>traceroute 会在路由的每一跳发送三个包，并在收到响应后，输出往返延时。如果无响应或者响应超时</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 记录一会（比如30s）后按Ctrl+C结束</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> perf record -a -g -- sleep 30</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出报告</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> perf report -g graph,0</span></span><br></pre></td></tr></table></figure>

<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="根据指标找工具"><a href="#根据指标找工具" class="headerlink" title="根据指标找工具"></a>根据指标找工具</h3><img src="/2021/12/21/4-%E7%BD%91%E7%BB%9C/%E6%8C%87%E6%A0%87%E6%89%BE%E5%B7%A5%E5%85%B7.webp" class="">

<h3 id="根据工具查指标"><a href="#根据工具查指标" class="headerlink" title="根据工具查指标"></a>根据工具查指标</h3><img src="/2021/12/21/4-%E7%BD%91%E7%BB%9C/%E5%B7%A5%E5%85%B7%E6%8C%87%E6%A0%87.webp" class="">

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/12/19/3-IO/" rel="prev" title="3.IO">
      <i class="fa fa-chevron-left"></i> 3.IO
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/12/22/5-%E6%A1%88%E4%BE%8B/" rel="next" title="5.案例">
      5.案例 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">网络相关概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.1.</span> <span class="nav-text">网络模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux-%E7%BD%91%E7%BB%9C%E6%A0%88"><span class="nav-number">1.2.</span> <span class="nav-text">Linux 网络栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="nav-number">1.3.</span> <span class="nav-text">Linux 网络收发流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#socket%E7%BC%96%E7%A8%8B"><span class="nav-number">1.4.</span> <span class="nav-text">socket编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="nav-number">1.5.</span> <span class="nav-text">性能指标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE"><span class="nav-number">1.6.</span> <span class="nav-text">网络配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%EF%BC%88ifconfig-ip%EF%BC%89"><span class="nav-number">1.6.1.</span> <span class="nav-text">查看网络配置（ifconfig&#x2F;ip）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E4%BF%A1%E6%81%AF"><span class="nav-number">1.6.2.</span> <span class="nav-text">套接字信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF"><span class="nav-number">1.6.3.</span> <span class="nav-text">协议栈统计信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%90%9E%E5%90%90%E5%92%8C-PPS"><span class="nav-number">1.6.4.</span> <span class="nav-text">网络吞吐和 PPS</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E9%80%9A%E6%80%A7%E5%92%8C%E5%BB%B6%E6%97%B6"><span class="nav-number">1.7.</span> <span class="nav-text">连通性和延时</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CK10"><span class="nav-number">1.8.</span> <span class="nav-text">CK10</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#I-O-%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8C%96"><span class="nav-number">1.8.1.</span> <span class="nav-text">I&#x2F;O 模型优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8C%96"><span class="nav-number">1.8.2.</span> <span class="nav-text">工作模型优化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C1000K"><span class="nav-number">1.9.</span> <span class="nav-text">C1000K</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C10M"><span class="nav-number">1.10.</span> <span class="nav-text">C10M</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95"><span class="nav-number">2.</span> <span class="nav-text">测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95"><span class="nav-number">2.1.</span> <span class="nav-text">网络基准测试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AC%E5%8F%91%E6%80%A7%E8%83%BD"><span class="nav-number">2.1.1.</span> <span class="nav-text">转发性能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-UDP-%E6%80%A7%E8%83%BD"><span class="nav-number">2.1.2.</span> <span class="nav-text">TCP&#x2F;UDP 性能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP-%E6%80%A7%E8%83%BD"><span class="nav-number">2.1.3.</span> <span class="nav-text">HTTP 性能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E8%B4%9F%E8%BD%BD%E6%80%A7%E8%83%BD"><span class="nav-number">2.1.4.</span> <span class="nav-text">应用负载性能</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcpdump-%E5%92%8C-Wireshark"><span class="nav-number">2.2.</span> <span class="nav-text">tcpdump 和 Wireshark</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#tcpdump"><span class="nav-number">2.2.1.</span> <span class="nav-text">tcpdump</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#wireshark"><span class="nav-number">2.2.2.</span> <span class="nav-text">wireshark</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A5%E5%85%B7"><span class="nav-number">3.</span> <span class="nav-text">工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE%E6%8C%87%E6%A0%87%E6%89%BE%E5%B7%A5%E5%85%B7"><span class="nav-number">3.1.</span> <span class="nav-text">根据指标找工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE%E5%B7%A5%E5%85%B7%E6%9F%A5%E6%8C%87%E6%A0%87"><span class="nav-number">3.2.</span> <span class="nav-text">根据工具查指标</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">sk-xinye</p>
  <div class="site-description" itemprop="description">愿所有努力都不被辜负</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">142</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sk-xinye</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
