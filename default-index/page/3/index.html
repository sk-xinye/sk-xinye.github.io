<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"sk-xinye.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.yml"};
  </script>

  <meta name="description" content="愿所有努力都不被辜负">
<meta property="og:type" content="website">
<meta property="og:title" content="sk-xinyeの博客">
<meta property="og:url" content="https://sk-xinye.github.io/default-index/page/3/index.html">
<meta property="og:site_name" content="sk-xinyeの博客">
<meta property="og:description" content="愿所有努力都不被辜负">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="sk-xinye">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://sk-xinye.github.io/default-index/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>sk-xinyeの博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">sk-xinyeの博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录学习的脚步</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-fa fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">1</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">18</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">142</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sk-xinye.github.io/2022/01/20/1-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sk-xinye">
      <meta itemprop="description" content="愿所有努力都不被辜负">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sk-xinyeの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/20/1-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/" class="post-title-link" itemprop="url">1.环境安装</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-20 12:38:42" itemprop="dateCreated datePublished" datetime="2022-01-20T12:38:42+08:00">2022-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-04 10:33:07" itemprop="dateModified" datetime="2023-02-04T10:33:07+08:00">2023-02-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="java-安装"><a href="#java-安装" class="headerlink" title="java 安装"></a>java 安装</h2><h3 id="下载解压"><a href="#下载解压" class="headerlink" title="下载解压"></a>下载解压</h3><p><a target="_blank" rel="noopener" href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p>
<p>x64 Compressed Archive 源码包</p>
<p>tar -zxvf jdk-8u321-linux-x64.tar.gz</p>
<h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>vim /etc/profile</p>
<p>export JAVA_HOME=/root/aliyun/jdk1.8.0_321<br>export JRE_HOME=$JAVA_HOME/jre<br>export PATH=$PATH:$JAVA_HOME/bin<br>export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</p>
<p>source /etc/profile</p>
<h3 id="检查环境"><a href="#检查环境" class="headerlink" title="检查环境"></a>检查环境</h3><p>java<br>java -version</p>
<h3 id="手动编译"><a href="#手动编译" class="headerlink" title="手动编译"></a>手动编译</h3><p>两个测试所需文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Hello Hello = <span class="keyword">new</span> Hello();</span><br><span class="line">        Hello.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="同目录下"><a href="#同目录下" class="headerlink" title="同目录下"></a>同目录下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">Demo.java</span><br><span class="line">Hello.java</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> javac Demo.java</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> java Demo</span></span><br></pre></td></tr></table></figure>

<h4 id="引入不同目录依赖编译执行"><a href="#引入不同目录依赖编译执行" class="headerlink" title="引入不同目录依赖编译执行"></a>引入不同目录依赖编译执行</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">Demo.java</span><br><span class="line">libs/</span><br><span class="line">    Hello.java</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> javac -classpath ./libs Demo.java</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> java -classpath .:libs Demo</span></span><br></pre></td></tr></table></figure>

<h4 id="引入jar包"><a href="#引入jar包" class="headerlink" title="引入jar包"></a>引入jar包</h4><p>将Hello.java打成jar包</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> libs</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> avac Hello.java</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> jar -cvf hello.jar Hello.class</span></span><br></pre></td></tr></table></figure>

<p>引入jar包执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">Demo.java</span><br><span class="line">libs/</span><br><span class="line">    hello.jar</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> javac -classpath ./libs/hello.jar  Demo.java</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> java -classpath .:./libs/hello.jar  Demo</span></span><br><span class="line"></span><br><span class="line">javac -classpath e:/import.jar;e:/tmp/import.jar -d destationpath test.java 引用多个jar包</span><br></pre></td></tr></table></figure>

<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> javac -encoding UTF-8 -classpath ./libs -d classes Demo.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数说明</span></span><br><span class="line">-encoding UTF-8    定源文件使用的字符编码</span><br><span class="line">-classpath ./libs  指定查找用户类文件和注释处理程序的位置</span><br><span class="line">-d classes         指定放置生成的类文件的位置，必须存在</span><br><span class="line">Demo.java          source files</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> classes</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> java Demo</span></span><br></pre></td></tr></table></figure>

<h2 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/YF_Li123/article/details/79953731">https://blog.csdn.net/YF_Li123/article/details/79953731</a>  helloword</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sk-xinye.github.io/2022/01/04/2-python%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sk-xinye">
      <meta itemprop="description" content="愿所有努力都不被辜负">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sk-xinyeの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/04/2-python%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/" class="post-title-link" itemprop="url">2.python常见用法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-04 11:04:22" itemprop="dateCreated datePublished" datetime="2022-01-04T11:04:22+08:00">2022-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-04 10:33:07" itemprop="dateModified" datetime="2023-02-04T10:33:07+08:00">2023-02-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> dateutil <span class="keyword">import</span> parser</span><br><span class="line">parser.parse(<span class="string">&quot;Aug 28 1999 12:00AM&quot;</span>)  <span class="comment"># datetime.datetime(1999, 8, 28, 0, 0)</span></span><br></pre></td></tr></table></figure>

<h2 id="py-spy"><a href="#py-spy" class="headerlink" title="py-spy"></a>py-spy</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/py3.6/ve1/bin/py-spy record -o /home/zshield/logs/profile.svg -- /opt/py3.6/ve1/bin/python3.8 -m main.pp2_main</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sk-xinye.github.io/2021/12/22/5-%E6%A1%88%E4%BE%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sk-xinye">
      <meta itemprop="description" content="愿所有努力都不被辜负">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sk-xinyeの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/22/5-%E6%A1%88%E4%BE%8B/" class="post-title-link" itemprop="url">5.案例</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-22 16:58:36" itemprop="dateCreated datePublished" datetime="2021-12-22T16:58:36+08:00">2021-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-04 10:33:07" itemprop="dateModified" datetime="2023-02-04T10:33:07+08:00">2023-02-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="docker-拒绝连接"><a href="#docker-拒绝连接" class="headerlink" title="docker 拒绝连接"></a>docker 拒绝连接</h2><p>问题：是由于docker 内程序占用了内存被oom kill掉了导致的</p>
<h2 id="丢包分析"><a href="#丢包分析" class="headerlink" title="丢包分析"></a>丢包分析</h2><img src="/2021/12/22/5-%E6%A1%88%E4%BE%8B/%E4%B8%A2%E5%8C%85.webp" class="">

<p>从图中你可以看出，可能发生丢包的位置，实际上贯穿了整个网络协议栈。换句话说，全程都有丢包的可能。比如我们从下往上看：</p>
<ul>
<li>在两台 VM 连接之间，可能会发生传输失败的错误，比如网络拥塞、线路错误等；</li>
<li>在网卡收包后，环形缓冲区可能会因为溢出而丢包；</li>
<li>在链路层，可能会因为网络帧校验失败、QoS 等而丢包；</li>
<li>在 IP 层，可能会因为路由失败、组包大小超过 MTU 等而丢包；</li>
<li>在传输层，可能会因为端口未监听、资源占用超过内核限制等而丢包；</li>
<li>在套接字层，可能会因为套接字缓冲区溢出而丢包；</li>
<li>在应用层，可能会因为应用程序异常而丢包；</li>
<li>此外，如果配置了 iptables 规则，这些网络包也可能因为 iptables 过滤规则而丢包。</li>
</ul>
<h3 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h3><p>当缓冲区溢出等原因导致网卡丢包时，Linux 会在网卡收发数据的统计信息中，记录下收发错误的次数。你可以通过 ethtool 或者 netstat ，来查看网卡的丢包记录。比如，可以在容器中执行下面的命令，查看丢包情况：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@nginx:/# netstat -i</span><br><span class="line">Kernel Interface table</span><br><span class="line">Iface      MTU    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg</span><br><span class="line">eth0       100       31      0      0 0             8      0      0      0 BMRU</span><br><span class="line">lo       65536        0      0      0 0             0      0      0      0 LRU</span><br></pre></td></tr></table></figure>

<p>RX-OK、RX-ERR、RX-DRP、RX-OVR，分别表示接收时的总包数、总错误数、进入 Ring Buffer 后因其他原因（如内存不足）导致的丢包数以及 Ring Buffer 溢出导致的丢包数。<br>TX-OK、TX-ERR、TX-DRP、TX-OVR 也代表类似的含义，只不过是指发送时对应的各个指标。</p>
<h3 id="网络层和传输层"><a href="#网络层和传输层" class="headerlink" title="网络层和传输层"></a>网络层和传输层</h3><p>netstat -s 命令，就可以看到协议的收发汇总，以及错误信息了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">root@nginx:/# netstat -s</span><br><span class="line">Ip:</span><br><span class="line">    Forwarding: 1          //开启转发</span><br><span class="line">    31 total packets received    //总收包数</span><br><span class="line">    0 forwarded            //转发包数</span><br><span class="line">    0 incoming packets discarded  //接收丢包数</span><br><span class="line">    25 incoming packets delivered  //接收的数据包数</span><br><span class="line">    15 requests sent out      //发出的数据包数</span><br><span class="line">Icmp:</span><br><span class="line">    0 ICMP messages received    //收到的ICMP包数</span><br><span class="line">    0 input ICMP message failed    //收到ICMP失败数</span><br><span class="line">    ICMP input histogram:</span><br><span class="line">    0 ICMP messages sent      //ICMP发送数</span><br><span class="line">    0 ICMP messages failed      //ICMP失败数</span><br><span class="line">    ICMP output histogram:</span><br><span class="line">Tcp:</span><br><span class="line">    0 active connection openings  //主动连接数</span><br><span class="line">    0 passive connection openings  //被动连接数</span><br><span class="line">    11 failed connection attempts  //失败连接尝试数</span><br><span class="line">    0 connection resets received  //接收的连接重置数</span><br><span class="line">    0 connections established    //建立连接数</span><br><span class="line">    25 segments received      //已接收报文数</span><br><span class="line">    21 segments sent out      //已发送报文数</span><br><span class="line">    4 segments retransmitted    //重传报文数</span><br><span class="line">    0 bad segments received      //错误报文数</span><br><span class="line">    0 resets sent          //发出的连接重置数</span><br><span class="line">Udp:</span><br><span class="line">    0 packets received</span><br><span class="line">    ...</span><br><span class="line">TcpExt:</span><br><span class="line">    11 resets received for embryonic SYN_RECV sockets  //半连接重置数</span><br><span class="line">    0 packet headers predicted</span><br><span class="line">    TCPTimeouts: 7    //超时数</span><br><span class="line">    TCPSynRetrans: 4  //SYN重传数</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h3><p>iptables 的原理，它基于 Netfilter 框架，通过一系列的规则，对网络数据包进行过滤（如防火墙）和修改（如 NAT）</p>
<p>这些 iptables 规则，统一管理在一系列的表中，包括 filter（用于过滤）、nat（用于 NAT）、mangle（用于修改分组数据） 和 raw（用于原始数据包）等。而每张表又可以包括一系列的链，用于对 iptables 规则进行分组管理。</p>
<h3 id="tcpdump抓包"><a href="#tcpdump抓包" class="headerlink" title="tcpdump抓包"></a>tcpdump抓包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@nginx:/# tcpdump -i eth0 -nn port 80</span><br><span class="line">tcpdump: verbose output suppressed, use -v or -vv for full protocol decode</span><br><span class="line">listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br></pre></td></tr></table></figure>

<h2 id="cpu利用率太高"><a href="#cpu利用率太高" class="headerlink" title="cpu利用率太高"></a>cpu利用率太高</h2><h3 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h3><p>我们知道，在 Linux 中，用户态进程的“祖先”，都是 PID 号为 1 的 init 进程。比如，现在主流的 Linux 发行版中，init 都是 systemd 进程；而其他的用户态进程，会通过 systemd 来进行管理。</p>
<p>实际上，Linux 在启动过程中，有三个特殊的进程，也就是 PID 号最小的三个进程。</p>
<ul>
<li>0 号进程为 idle 进程，这也是系统创建的第一个进程，它在初始化 1 号和 2 号进程后，演变为空闲任务。当 CPU 上没有其他任务执行时，就会运行它。</li>
<li>1 号进程为 init 进程，通常是 systemd 进程，在用户态运行，用来管理其他用户态进程。</li>
<li>2 号进程为 kthreadd 进程，在内核态运行，用来管理内核线程。</li>
</ul>
<h3 id="火焰图"><a href="#火焰图" class="headerlink" title="火焰图"></a>火焰图</h3><p>安装好工具后，要生成火焰图，其实主要需要三个步骤：</p>
<ul>
<li>执行 perf script ，将 perf record 的记录转换成可读的采样记录；</li>
<li>执行 stackcollapse-perf.pl 脚本，合并调用栈信息；</li>
<li>执行 flamegraph.pl 脚本，生成火焰图。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">生成火焰图</span><br><span class="line"><span class="meta">$</span><span class="bash"> perf script -i /root/perf.data | ./stackcollapse-perf.pl --all |  ./flamegraph.pl &gt; ksoftirqd.svg</span></span><br><span class="line">执行成功后，使用浏览器打开 ksoftirqd.svg ，你就可以看到生成的火焰图了</span><br></pre></td></tr></table></figure>

<p>动态追踪技术，通过探针机制，来采集内核或者应用程序的运行信息，从而可以不用修改内核和应用程序的代码，就获得丰富的信息，帮你分析、定位想要排查的问题</p>
<h2 id="动态追踪（Dynamic-Tracing）"><a href="#动态追踪（Dynamic-Tracing）" class="headerlink" title="动态追踪（Dynamic Tracing）"></a>动态追踪（Dynamic Tracing）</h2><h3 id="动态追踪的事件源"><a href="#动态追踪的事件源" class="headerlink" title="动态追踪的事件源"></a>动态追踪的事件源</h3><p>根据事件类型的不同，动态追踪所使用的事件源，可以分为静态探针、动态探针以及硬件事件等三类。它们的关系如下图所示：</p>
<h3 id="动态追踪机制"><a href="#动态追踪机制" class="headerlink" title="动态追踪机制"></a>动态追踪机制</h3><p>Linux 也提供了一系列的动态追踪机制，比如 ftrace、perf、eBPF 等。</p>
<p>eBPF 则在 BPF（Berkeley Packet Filter）的基础上扩展而来，不仅支持事件跟踪机制，还可以通过自定义的 BPF 代码（使用 C 语言）来自由扩展。所以，eBPF 实际上就是常驻于内核的运行时，可以说就是 Linux 版的 DTrace。</p>
<p>除此之外，还有很多内核外的工具，也提供了丰富的动态追踪功能。最常见的就是前面提到的 SystemTap，我们之前多次使用过的 BCC（BPF Compiler Collection），以及常用于容器性能分析的 sysdig 等。</p>
<h2 id="perf"><a href="#perf" class="headerlink" title="perf"></a>perf</h2><p>perf 可以用来分析 CPU cache、CPU 迁移、分支预测、指令周期等各种硬件事件；perf 也可以只对感兴趣的事件进行动态追踪。</p>
<h2 id="eBPF-和-BCC"><a href="#eBPF-和-BCC" class="headerlink" title="eBPF 和 BCC"></a>eBPF 和 BCC</h2><p>ftrace 和 perf 的功能已经比较丰富了，不过，它们有一个共同的缺陷，那就是不够灵活，没法像 DTrace 那样通过脚本自由扩展。</p>
<p>而 eBPF 就是 Linux 版的 DTrace，可以通过 C 语言自由扩展（这些扩展通过 LLVM 转换为 BPF 字节码后，加载到内核中执行）。下面这张图，就表示了 eBPF 追踪的工作原理：</p>
<img src="/2021/12/22/5-%E6%A1%88%E4%BE%8B/bpf.webp" class="">

<p>从图中你可以看到，eBPF 的执行需要三步：</p>
<p>从用户跟踪程序生成 BPF 字节码；<br>加载到内核中运行；<br>向用户空间输出结果。</p>
<p>实际上，在 eBPF 执行过程中，编译、加载还有 maps 等操作，对所有的跟踪程序来说都是通用的。把这些过程通过 Python 抽象起来，也就诞生了 BCC（BPF Compiler Collection）。</p>
<img src="/2021/12/22/5-%E6%A1%88%E4%BE%8B/%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA%E5%B7%A5%E5%85%B7.webp" class="">

<h2 id="系统优化"><a href="#系统优化" class="headerlink" title="系统优化"></a>系统优化</h2><h3 id="CPU-优化"><a href="#CPU-优化" class="headerlink" title="CPU 优化"></a>CPU 优化</h3><p>CPU 性能优化的核心，在于排除所有不必要的工作、充分利用 CPU 缓存并减少进程调度对性能的影响。</p>
<ul>
<li>第一种，把进程绑定到一个或者多个 CPU 上，充分利用 CPU 缓存的本地性，并减少进程间的相互影响。</li>
<li>第二种，为中断处理程序开启多 CPU 负载均衡，以便在发生大量中断时，可以充分利用多 CPU 的优势分摊负载。</li>
<li>第三种，使用 Cgroups 等方法，为进程设置资源限制，避免个别进程消耗过多的 CPU。同时，为核心应用程序设置更高的优先级，减少低优先级任务的影响。</li>
</ul>
<h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><ul>
<li>第一种，除非有必要，Swap 应该禁止掉。这样就可以避免 Swap 的额外 I/O ，带来内存访问变慢的问题。</li>
<li>第二种，使用 Cgroups 等方法，为进程设置内存限制。这样就可以避免个别进程消耗过多内存，而影响了其他进程。对于核心应用，还应该降低 oom_score，避免被 OOM 杀死。</li>
<li>第三种，使用大页、内存池等方法，减少内存的动态分配，从而减少缺页异常。</li>
</ul>
<h3 id="磁盘和文件系统-I-O-优化"><a href="#磁盘和文件系统-I-O-优化" class="headerlink" title="磁盘和文件系统 I/O 优化"></a>磁盘和文件系统 I/O 优化</h3><ul>
<li>第一种，也是最简单的方法，通过 SSD 替代 HDD、或者使用 RAID 等方法，提升 I/O 性能。</li>
<li>第二种，针对磁盘和应用程序 I/O 模式的特征，选择最适合的 I/O 调度算法。比如，SSD 和虚拟机中的磁盘，通常用的是 noop 调度算法；而数据库应用，更推荐使用 deadline 算法。</li>
<li>第三，优化文件系统和磁盘的缓存、缓冲区，比如优化脏页的刷新频率、脏页限额，以及内核回收目录项缓存和索引节点缓存的倾向等等。</li>
<li>除此之外，使用不同磁盘隔离不同应用的数据、优化文件系统的配置选项、优化磁盘预读、增大磁盘队列长度等，也都是常用的优化思路。</li>
</ul>
<h3 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h3><ul>
<li>首先，从内核资源和网络协议的角度来说，我们可以对内核选项进行优化，比如：<ul>
<li>你可以增大套接字缓冲区、连接跟踪表、最大半连接数、最大文件描述符数、本地端口范围等内核资源配额；</li>
<li>也可以减少 TIMEOUT 超时时间、SYN+ACK 重传数、Keepalive 探测时间等异常处理参数；</li>
<li>还可以开启端口复用、反向地址校验，并调整 MTU 大小等降低内核的负担。</li>
</ul>
</li>
<li>其次，从网络接口的角度来说，我们可以考虑对网络接口的功能进行优化，比如：<ul>
<li>你可以将原来 CPU 上执行的工作，卸载到网卡中执行，即开启网卡的 GRO、GSO、RSS、VXLAN 等卸载功能；</li>
<li>也可以开启网络接口的多队列功能，这样，每个队列就可以用不同的中断号，调度到不同 CPU 上执行；</li>
<li>还可以增大网络接口的缓冲区大小以及队列长度等，提升网络传输的吞吐量。</li>
</ul>
</li>
<li>最后，在极限性能情况（比如 C10M）下，内核的网络协议栈可能是最主要的性能瓶颈，所以，一般会考虑绕过内核协议栈。<ul>
<li>你可以使用 DPDK 技术，跳过内核协议栈，直接由用户态进程用轮询的方式，来处理网络请求。同时，再结合大页、CPU 绑定、内存对齐、流水线并发等多种机制，优化网络包的处理效率。</li>
<li>你还可以使用内核自带的 XDP 技术，在网络包进入内核协议栈前，就对其进行处理。这样，也可以达到目的，获得很好的性能。</li>
</ul>
</li>
</ul>
<h2 id="应用程序优化"><a href="#应用程序优化" class="headerlink" title="应用程序优化"></a>应用程序优化</h2><ul>
<li>第一，从 CPU 使用的角度来说，简化代码、优化算法、异步处理以及编译器优化等，都是常用的降低 CPU 使用率的方法，这样可以利用有限的 CPU 处理更多的请求。</li>
<li>第二，从数据访问的角度来说，使用缓存、写时复制、增加 I/O 尺寸等，都是常用的减少磁盘 I/O 的方法，这样可以获得更快的数据处理速度。</li>
<li>第三，从内存管理的角度来说，使用大页、内存池等方法，可以预先分配内存，减少内存的动态分配，从而更好地内存访问性能。</li>
<li>第四，从网络的角度来说，使用 I/O 多路复用、长连接代替短连接、DNS 缓存等方法，可以优化网络 I/O 并减少网络请求数，从而减少网络延时带来的性能问题。</li>
<li>第五，从进程的工作模型来说，异步处理、多线程或多进程等，可以充分利用每一个 CPU 的处理能力，从而提高应用程序的吞吐能力。</li>
<li>你还可以使用消息队列、CDN、负载均衡等各种方法，来优化应用程序的架构，将原来单机要承担的任务，调度到多台服务器中并行处理。这样也往往能获得更好的整体性能。</li>
</ul>
<h2 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h2><p><a target="_blank" rel="noopener" href="https://fasionchan.com/posts/debug-python-with-gdb/">https://fasionchan.com/posts/debug-python-with-gdb/</a><br><a target="_blank" rel="noopener" href="https://meteorix.github.io/2019/02/13/gdbpython/">https://meteorix.github.io/2019/02/13/gdbpython/</a></p>
<ol>
<li>准备 yum install gdb &lt;python-dbg,目前这个centos不好安装，可不装&gt;</li>
<li>准备代码</li>
<li>gdb /opt/py3.8/ve1/bin/python <process id> 执行</li>
<li>python—-&gt; import sys —–&gt;sys.path.insert(0,/root(这个下面存放libpython.py文件,或者append也可以)) —–&gt;import libpython —–&gt;end</li>
<li>bt py-bt py-list</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">参考文档 ：https://fasionchan.com/posts/debug-python-with-gdb/  https://meteorix.github.io/2019/02/13/gdbpython/</span><br><span class="line">gdb /home/zshield/data_interconnect/py/ve1/bin/python core.22614</span><br><span class="line">bt</span><br></pre></td></tr></table></figure>

<h3 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bt    # 当前C调用栈</span><br><span class="line">py-bt  # 当前Py调用栈</span><br><span class="line">py-list  # 当前py代码位置</span><br><span class="line">info thread   # 线程信息</span><br><span class="line">thread &lt;id&gt;   # 切换到某个线程</span><br><span class="line">thread apply all py-list  # 查看所有线程的py代码位置</span><br><span class="line">ctrl-c  # 中断</span><br></pre></td></tr></table></figure>

<h3 id="磁盘信息收集"><a href="#磁盘信息收集" class="headerlink" title="磁盘信息收集"></a>磁盘信息收集</h3><p>lspci |grep -i raid</p>
<ol>
<li><p>smartctl –scan 查看hdd信息</p>
</li>
<li><p>lsblk/lsscsi/blkid  获取挂载盘</p>
</li>
<li><p>./storcli64 /c0 show  确定raid信息  <a target="_blank" rel="noopener" href="https://support.huawei.com/enterprise/zh/doc/EDOC1000163568/219f7d6d">https://support.huawei.com/enterprise/zh/doc/EDOC1000163568/219f7d6d</a></p>
</li>
<li><p>pvdisplay  确定物理卷</p>
</li>
<li><p>vgdisplay  确定卷组</p>
</li>
<li><p>lvdisplay  确定逻辑卷</p>
</li>
<li><p>可以通过lsblk 验证</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sk-xinye.github.io/2021/12/21/4-%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sk-xinye">
      <meta itemprop="description" content="愿所有努力都不被辜负">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sk-xinyeの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/21/4-%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">4.网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-21 10:19:51" itemprop="dateCreated datePublished" datetime="2021-12-21T10:19:51+08:00">2021-12-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-04 10:33:07" itemprop="dateModified" datetime="2023-02-04T10:33:07+08:00">2023-02-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="网络相关概念"><a href="#网络相关概念" class="headerlink" title="网络相关概念"></a>网络相关概念</h2><h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><img src="/2021/12/21/4-%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.webp" class="">

<h3 id="Linux-网络栈"><a href="#Linux-网络栈" class="headerlink" title="Linux 网络栈"></a>Linux 网络栈</h3><img src="/2021/12/21/4-%E7%BD%91%E7%BB%9C/linux%E7%BD%91%E7%BB%9C.webp" class="">

<ul>
<li>传输层在应用程序数据前面增加了 TCP 头；</li>
<li>网络层在 TCP 数据包前增加了 IP 头；</li>
<li>而网络接口层，又在 IP 数据包前后分别增加了帧头和帧尾。</li>
</ul>
<img src="/2021/12/21/4-%E7%BD%91%E7%BB%9C/linux%E7%BD%91%E7%BB%9C%E6%A0%88.webp" class="">

<ul>
<li>最上层的应用程序，需要通过系统调用，来跟套接字接口进行交互；</li>
<li>套接字的下面，就是我们前面提到的传输层、网络层和网络接口层；</li>
<li>最底层，则是网卡驱动程序以及物理网卡设备。</li>
</ul>
<p>这里我简单说一下网卡。网卡是发送和接收网络包的基本设备。在系统启动过程中，网卡通过内核中的网卡驱动程序注册到系统中。而在网络收发过程中，内核通过中断跟网卡进行交互。</p>
<h3 id="Linux-网络收发流程"><a href="#Linux-网络收发流程" class="headerlink" title="Linux 网络收发流程"></a>Linux 网络收发流程</h3><img src="/2021/12/21/4-%E7%BD%91%E7%BB%9C/linux%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91.webp" class="">

<ul>
<li>当一个网络帧到达网卡后，网卡会通过 DMA 方式，把这个网络包放到收包队列中；</li>
<li>然后通过硬中断，告诉中断处理程序已经收到了网络包。</li>
<li>网卡中断处理程序会为网络帧分配内核数据结构（sk_buff），并将其拷贝到 sk_buff 缓冲区中；</li>
<li>然后再通过软中断，通知内核收到了新的网络帧。</li>
<li>在链路层检查报文的合法性，找出上层协议的类型（比如 IPv4 还是 IPv6），再去掉帧头、帧尾，然后交给网络层。</li>
<li>网络层取出 IP 头，判断网络包下一步的走向，比如是交给上层处理还是转发。当网络层确认这个包是要发送到本机后，就会取出上层协议的类型（比如 TCP 还是 UDP），去掉 IP 头，再交给传输层处理。</li>
<li>传输层取出 TCP 头或者 UDP 头后，根据 &lt; 源 IP、源端口、目的 IP、目的端口 &gt; 四元组作为标识，找出对应的 Socket，并把数据拷贝到 Socket 的接收缓存中。</li>
<li>应用程序就可以使用 Socket 接口，读取到新接收到的数据了</li>
</ul>
<h3 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h3><ul>
<li>服务端首先创建socket文件，然后bind监听，最后listen()</li>
<li>客户端创建socket文件，connect() 开始与服务端进行3次连接</li>
<li>3次握手涉及到2个队列，未完成连接队列（接收到syn 还未得到客户端确认），已连接队列（接收到了客户端的确认）</li>
<li>应用程序通过accept()从已连接队列中拿到连接的socket fd，然后生成新的socket fd 返回给客户端用户通信</li>
<li>当使用io多路复用器时（select poll epoll）,就可以同时监听多个文件描述符了,核心就是告诉我们哪些文件描述符可读，哪些文件描述符可写<ul>
<li>select：程序把文件描述符集合交给select的系统调用，select遍历每个文件描述符后返回那些可以操作的文件描述符，然后客户端就可以进行读写了。但文件描述符集合大小有限制为1024个</li>
<li>poll 在文件描述符集合的限制上进行了改进</li>
<li>select和poll都有缺点：每次都要将文件描述符集合从用户态到内核态，并从内核态到用户态，而且内核和用户态都需要遍历文件描述符集合</li>
<li>epoll有点：当数据到达网卡时，会触发中断，正常情况下cpu会把相应的数据复制到内存中，和相关文件描述符进行绑定。epoll在这个基础上做了延伸，epoll首先是在内核中维护了一个红黑树，以及一些链表结构，当数据到达网卡拷贝到内存时会把相应的文件描述符从红黑树中拷贝到链表中，这样链表存储的就是已经到达数据的文件描述符，这样当程序调用epoll_wait的时候就能直接把能读的文件描述符返回给应用程序</li>
<li>除了epoll_wait外，epoll还有两个系统调用，分别是epoll_create 和epoll_ctl（这里需要将文件描述符拷贝到内核态）。分别用于初始化epoll和把文件描述符添加到红黑树中</li>
<li>java中selector就是对select、poll、epoll的封装</li>
</ul>
</li>
</ul>
<h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><ul>
<li>带宽，表示链路的最大传输速率，单位通常为 b/s （比特 / 秒）。</li>
<li>吞吐量，表示单位时间内成功传输的数据量，单位通常为 b/s（比特 / 秒）或者 B/s（字节 / 秒）。吞吐量受带宽限制，而吞吐量 / 带宽，也就是该网络的使用率。</li>
<li>延时，表示从网络请求发出后，一直到收到远端响应，所需要的时间延迟。在不同场景中，这一指标可能会有不同含义。比如，它可以表示，建立连接需要的时间（比如 TCP 握手延时），或一个数据包往返所需的时间（比如 RTT）。</li>
<li>PPS，是 Packet Per Second（包 / 秒）的缩写，表示以网络包为单位的传输速率。PPS 通常用来评估网络的转发能力，比如硬件交换机，通常可以达到线性转发（即 PPS 可以达到或者接近理论最大值）。而基于 Linux 服务器的转发，则容易受网络包大小的影响。</li>
<li>除了以上指标还包括网络的可用性（网络能否正常通信）、并发连接数（TCP 连接数量）、丢包率（丢包百分比）、重传率（重新传输的网络包比例）等也是常用的性能指标。</li>
<li>对 TCP 或者 Web 服务来说，更多会用并发连接数和每秒请求数（QPS，Query per Second）等指标，它们更能反应实际应用程序的性能。</li>
</ul>
<h3 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h3><h4 id="查看网络配置（ifconfig-ip）"><a href="#查看网络配置（ifconfig-ip）" class="headerlink" title="查看网络配置（ifconfig/ip）"></a>查看网络配置（ifconfig/ip）</h4><p>ifconfig 和 ip 分别属于软件包 net-tools 和 iproute2，iproute2 是 net-tools 的下一代。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ifconfig eth0</span></span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500</span><br><span class="line">      inet 10.240.0.30 netmask 255.240.0.0 broadcast 10.255.255.255</span><br><span class="line">      inet6 fe80::20d:3aff:fe07:cf2a prefixlen 64 scopeid 0x20&lt;link&gt;</span><br><span class="line">      ether 78:0d:3a:07:cf:3a txqueuelen 1000 (Ethernet)</span><br><span class="line">      RX packets 40809142 bytes 9542369803 (9.5 GB)</span><br><span class="line">      RX errors 0 dropped 0 overruns 0 frame 0</span><br><span class="line">      TX packets 32637401 bytes 4815573306 (4.8 GB)</span><br><span class="line">      TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ip -s addr show dev eth0</span></span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000</span><br><span class="line">  link/ether 78:0d:3a:07:cf:3a brd ff:ff:ff:ff:ff:ff</span><br><span class="line">  inet 10.240.0.30/12 brd 10.255.255.255 scope global eth0</span><br><span class="line">      valid_lft forever preferred_lft forever</span><br><span class="line">  inet6 fe80::20d:3aff:fe07:cf2a/64 scope link</span><br><span class="line">      valid_lft forever preferred_lft forever</span><br><span class="line">  RX: bytes packets errors dropped overrun mcast</span><br><span class="line">   9542432350 40809397 0       0       0       193</span><br><span class="line">  TX: bytes packets errors dropped carrier collsns</span><br><span class="line">   4815625265 32637658 0       0       0       0</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>第一，网络接口的状态标志。ifconfig 输出中的 RUNNING ，或 ip 输出中的 LOWER_UP ，都表示物理网络是连通的，即网卡已经连接到了交换机或者路由器中。如果你看不到它们，通常表示网线被拔掉了</li>
<li>第二，MTU 的大小。MTU 默认大小是 1500，根据网络架构的不同（比如是否使用了 VXLAN 等叠加网络），你可能需要调大或者调小 MTU 的数值。</li>
<li>第三，网络接口的 IP 地址、子网以及 MAC 地址。这些都是保障网络功能正常工作所必需的，你需要确保配置正确。</li>
<li>第四，网络收发的字节数、包数、错误数以及丢包情况，特别是 TX 和 RX 部分的 errors、dropped、overruns、carrier 以及 collisions 等指标不为 0 时，通常表示出现了网络 I/O 问题。其中：<ul>
<li>errors 表示发生错误的数据包数，比如校验错误、帧同步错误等；</li>
<li>dropped 表示丢弃的数据包数，即数据包已经收到了 Ring Buffer，但因为内存不足等原因丢包；</li>
<li>overruns 表示超限数据包数，即网络 I/O 速度过快，导致 Ring Buffer 中的数据包来不及处理（队列满）而导致的丢包；</li>
<li>carrier 表示发生 carrirer 错误的数据包数，比如双工模式不匹配、物理电缆出现问题等；</li>
<li>collisions 表示碰撞数据包数。</li>
</ul>
</li>
</ul>
<h4 id="套接字信息"><a href="#套接字信息" class="headerlink" title="套接字信息"></a>套接字信息</h4><p>你可以用 netstat 或者 ss（推荐） ，来查看套接字、网络栈、网络接口以及路由表的信息。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> head -n 3 表示只显示前面3行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -l 表示只显示监听套接字</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -n 表示显示数字地址和端口(而不是名字)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -p 表示显示进程信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> netstat -nlp | head -n 3</span></span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name</span><br><span class="line">tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN      840/systemd-resolve</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -l 表示只显示监听套接字</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -t 表示只显示 TCP 套接字</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -n 表示显示数字地址和端口(而不是名字)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -p 表示显示进程信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ss -ltnp | head -n 3</span></span><br><span class="line">State    Recv-Q    Send-Q        Local Address:Port        Peer Address:Port</span><br><span class="line">LISTEN   0         128           127.0.0.53%lo:53               0.0.0.0:*        users:((&quot;systemd-resolve&quot;,pid=840,fd=13))</span><br><span class="line">LISTEN   0         128                 0.0.0.0:22               0.0.0.0:*        users:((&quot;sshd&quot;,pid=1459,fd=3))</span><br></pre></td></tr></table></figure>

<p>其中，接收队列（Recv-Q）和发送队列（Send-Q）需要你特别关注，它们通常应该是 0。当你发现它们不是 0 时，说明有网络包的堆积发生。</p>
<ul>
<li>当套接字处于连接状态（Established）时，Recv-Q 表示套接字缓冲还没有被应用程序取走的字节数（即接收队列长度）。而 Send-Q 表示还没有被远端主机确认的字节数（即发送队列长度）。</li>
<li>当套接字处于监听状态（Listening）时，Recv-Q 表示全连接队列的长度。而 Send-Q 表示全连接队列的最大长度。</li>
</ul>
<h4 id="协议栈统计信息"><a href="#协议栈统计信息" class="headerlink" title="协议栈统计信息"></a>协议栈统计信息</h4><p>使用 netstat 或 ss ，也可以查看协议栈的信息：</p>
<ul>
<li>ss 只显示已经连接、关闭、孤儿套接字等简要统计</li>
<li>而 netstat 则提供的是更详细的网络协议栈信息。比如，上面 netstat 的输出示例，就展示了 TCP 协议的主动连接、被动连接、失败重试、发送和接收的分段数量等各种信息。</li>
</ul>
<h4 id="网络吞吐和-PPS"><a href="#网络吞吐和-PPS" class="headerlink" title="网络吞吐和 PPS"></a>网络吞吐和 PPS</h4><p>sar 增加 -n 参数就可以查看网络的统计信息，比如网络接口（DEV）、网络接口错误（EDEV）、TCP、UDP、ICMP 等等。执行下面的命令，你就可以得到网络接口统计信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 数字1表示每隔1秒输出一组数据</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sar -n DEV 1</span></span><br><span class="line">Linux 4.15.0-1035 (ubuntu)   01/06/19   _x86_64_  (2 CPU)</span><br><span class="line"></span><br><span class="line">13:21:40        IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil</span><br><span class="line">13:21:41         eth0     18.00     20.00      5.79      4.25      0.00      0.00      0.00      0.00</span><br><span class="line">13:21:41      docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">13:21:41           lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br></pre></td></tr></table></figure>

<ul>
<li>rxpck/s 和 txpck/s 分别是接收和发送的 PPS，单位为包 / 秒。</li>
<li>rxkB/s 和 txkB/s 分别是接收和发送的吞吐量，单位是 KB/ 秒。</li>
<li>rxcmp/s 和 txcmp/s 分别是接收和发送的压缩数据包数，单位是包 / 秒。</li>
<li>%ifutil 是网络接口的使用率，即半双工模式下为 (rxkB/s+txkB/s)/Bandwidth，而全双工模式下为 max(rxkB/s, txkB/s)/Bandwidth。</li>
</ul>
<p>Bandwidth 可以用 ethtool 来查询，它的单位通常是 Gb/s 或者 Mb/s，不过注意这里小写字母 b ，表示比特而不是字节。我们通常提到的千兆网卡、万兆网卡等，单位也都是比特。如下你可以看到，我的 eth0 网卡就是一个千兆网卡：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ethtool eth0 | grep Speed</span></span><br><span class="line">  Speed: 1000Mb/s</span><br></pre></td></tr></table></figure>

<h3 id="连通性和延时"><a href="#连通性和延时" class="headerlink" title="连通性和延时"></a>连通性和延时</h3><p>我们通常使用 ping ，来测试远程主机的连通性和延时，而这基于 ICMP 协议。比如，执行下面的命令，你就可以测试本机到 114.114.114.114 这个 IP 地址的连通性和延时：</p>
<h3 id="CK10"><a href="#CK10" class="headerlink" title="CK10"></a>CK10</h3><h4 id="I-O-模型优化"><a href="#I-O-模型优化" class="headerlink" title="I/O 模型优化"></a>I/O 模型优化</h4><ul>
<li>水平触发（Level Trigger，LT）：只要文件描述符可以非阻塞地执行 I/O ，就会触发通知。也就是说，应用程序可以随时检查文件描述符的状态，然后再根据状态，进行 I/O 操作。</li>
<li>边缘触发（Edge Trigger，ET）：只有在文件描述符的状态发生改变（也就是 I/O 请求达到）时，才发送一次通知。这时候，应用程序需要尽可能多地执行 I/O，直到无法继续读写，才可以停止。如果 I/O 没执行完，或者因为某种原因没来得及处理，那么这次通知也就丢失了。</li>
</ul>
<p>区别：</p>
<ul>
<li>对于水平触发模式，一个事件只要有，就会一直触发；</li>
<li>对于边缘触发模式，只有一个事件从无到有才会触发。</li>
</ul>
<p>这两个词汇来自电学术语，你可以将 fd 上有数据认为是高电平，没有数据认为是低电平，将 fd 可写认为是高电平，fd 不可写认为是低电平。那么水平模式的触发条件是状态处于高电平，而边缘模式的触发条件是新来一次电信号将当前状态变为高电平，即：</p>
<ul>
<li>水平模式的触发条件：1. 低电平 =&gt; 高电平 2. 处于高电平状态</li>
<li>边缘模式的触发条件：1. 低电平 =&gt; 高电平</li>
</ul>
<p>说的有点抽象，以 socket 的读事件为例，对于水平模式，只要 socket 上有未读完的数据，就会一直产生 EPOLLIN 事件；而对于边缘模式，socket 上每新来一次数据就会触发一次，如果上一次触发后，未将 socket 上的数据读完，也不会再触发，除非再新来一次数据。对于 socket 写事件，如果 socket 的 TCP 窗口一直不饱和，会一直触发 EPOLLOUT 事件；而对于边缘模式，只会触发一次，除非 TCP 窗口由不饱和变成饱和再一次变成不饱和，才会再次触发 EPOLLOUT 事件。</p>
<ul>
<li>socket 可读事件水平模式触发条件：1. socket上无数据 =&gt; socket上有数据 2. socket处于有数据状态</li>
<li>socket 可读事件边缘模式触发条件：1. socket上无数据 =&gt; socket上有数据 2. socket又新来一次数据</li>
<li>socket 可写事件水平模式触发条件：1. socket可写   =&gt; socket可写 2. socket不可写 =&gt; socket可写</li>
<li>socket 可写事件边缘模式触发条件：1. socket不可写 =&gt; socket可写</li>
</ul>
<p>I/O 多路复用的方法。这里其实有很多实现方法，我带你来逐个分析一下。</p>
<ul>
<li>第一种，使用非阻塞 I/O 和水平触发通知，比如使用 select 或者 poll。</li>
<li>第二种，使用非阻塞 I/O 和边缘触发通知，比如 epoll。<ul>
<li>epoll 使用红黑树，在内核中管理文件描述符的集合，这样，就不需要应用程序在每次操作时都传入、传出这个集合。</li>
<li>epoll 使用事件驱动的机制，只关注有 I/O 事件发生的文件描述符，不需要轮询扫描整个集合。</li>
</ul>
</li>
<li>第三种，使用异步 I/O（Asynchronous I/O，简称为 AIO）。<ul>
<li>异步 I/O 允许应用程序同时发起很多 I/O 操作，而不用等待这些操作完成。而在 I/O 完成后，系统会用事件通知（比如信号或者回调函数）的方式，告诉应用程序。这时，应用程序才会去查询 I/O 操作的结果。</li>
</ul>
</li>
</ul>
<h4 id="工作模型优化"><a href="#工作模型优化" class="headerlink" title="工作模型优化"></a>工作模型优化</h4><p><strong>第一种</strong>，主进程 + 多个 worker 子进程，这也是最常用的一种模型。</p>
<ul>
<li>主进程执行 bind() + listen() 后，创建多个子进程；</li>
<li>然后，在每个子进程中，都通过 accept() 或 epoll_wait() ，来处理相同的套接字。</li>
</ul>
<p>最常用的反向代理服务器 Nginx 就是这么工作的。它也是由主进程和多个 worker 进程组成。主进程主要用来初始化套接字，并管理子进程的生命周期；而 worker 进程，则负责实际的请求处理。我画了一张图来表示这个关系。</p>
<img src="/2021/12/21/4-%E7%BD%91%E7%BB%9C/%E4%B8%80%E4%B8%BB%E5%A4%9A%E4%BB%8E%E6%A8%A1%E5%9E%8B.webp" class="">

<p>为了避免惊群问题， Nginx 在每个 worker 进程中，都增加一个了全局锁（accept_mutex）。这些 worker 进程需要首先竞争到锁，只有竞争到锁的进程，才会加入到 epoll 中，这样就确保只有一个 worker 子进程被唤醒。</p>
<p><strong>第二种</strong>，监听到相同端口的多进程模型。</p>
<p>在这种方式下，所有的进程都监听相同的接口，并且开启 SO_REUSEPORT 选项，由内核负责将请求负载均衡到这些监听进程中去。这一过程如下图所示。</p>
<img src="/2021/12/21/4-%E7%BD%91%E7%BB%9C/%E5%A4%9A%E4%B8%BB%E6%A8%A1%E5%9E%8B.webp" class="">

<h3 id="C1000K"><a href="#C1000K" class="headerlink" title="C1000K"></a>C1000K</h3><p>从 C10K 到 C100K ，可能只需要增加系统的物理资源就可以满足；但从 C100K 到 C1000K ，就不仅仅是增加物理资源就能解决的问题了。这时，就需要多方面的优化工作了，从硬件的中断处理和网络功能卸载、到网络协议栈的文件描述符数量、连接状态跟踪、缓存队列等内核的优化，再到应用程序的工作模型优化，都是考虑的重点。</p>
<h3 id="C10M"><a href="#C10M" class="headerlink" title="C10M"></a>C10M</h3><p>要实现 C10M ，就不只是增加物理资源，或者优化内核和应用程序可以解决的问题了。这时候，就需要用 XDP 的方式，在内核协议栈之前处理网络包；或者用 DPDK 直接跳过网络协议栈，在用户空间通过轮询的方式直接处理网络包。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="网络基准测试"><a href="#网络基准测试" class="headerlink" title="网络基准测试"></a>网络基准测试</h3><p>根据前面学过的 TCP/IP 协议栈的原理，这个问题应该不难回答。比如：</p>
<ul>
<li>基于 HTTP 或者 HTTPS 的 Web 应用程序，显然属于应用层，需要我们测试 HTTP/HTTPS 的性能；</li>
<li>而对大多数游戏服务器来说，为了支持更大的同时在线人数，通常会基于 TCP 或 UDP ，与客户端进行交互，这时就需要我们测试 TCP/UDP 的性能；</li>
<li>当然，还有一些场景，是把 Linux 作为一个软交换机或者路由器来用的。这种情况下，你更关注网络包的处理能力（即 PPS），重点关注网络层的转发性能。</li>
</ul>
<h4 id="转发性能"><a href="#转发性能" class="headerlink" title="转发性能"></a>转发性能</h4><p>36 hping3</p>
<h4 id="TCP-UDP-性能"><a href="#TCP-UDP-性能" class="headerlink" title="TCP/UDP 性能"></a>TCP/UDP 性能</h4><p>iperf 或者 netperf。iperf 和 netperf 都是最常用的网络性能测试工具，测试 TCP 和 UDP 的吞吐量。它们都以客户端和服务器通信的方式，测试一段时间内的平均吞吐量。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">在目标机器上启动 iperf 服务端：</span><br><span class="line"><span class="meta">#</span><span class="bash"> -s表示启动服务端，-i表示汇报间隔，-p表示监听端口</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iperf3 -s -i 1 -p 10000</span></span><br><span class="line"></span><br><span class="line">在另一台机器上运行 iperf 客户端，运行测试：</span><br><span class="line"><span class="meta">#</span><span class="bash"> -c表示启动客户端，192.168.0.30为目标服务器的IP</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -b表示目标带宽(单位是bits/s)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -t表示测试时间</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -P表示并发数，-p表示目标服务器监听端口</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iperf3 -c 192.168.0.30 -b 1G -t 15 -P 2 -p 10000</span></span><br><span class="line"></span><br><span class="line">稍等一会儿（15 秒）测试结束后，回到目标服务器，查看 iperf 的报告：</span><br><span class="line">[ ID] Interval           Transfer     Bandwidth</span><br><span class="line">...</span><br><span class="line">[SUM]   0.00-15.04  sec  0.00 Bytes  0.00 bits/sec                  sender</span><br><span class="line">[SUM]   0.00-15.04  sec  1.51 GBytes   860 Mbits/sec                  receiver</span><br></pre></td></tr></table></figure>

<h4 id="HTTP-性能"><a href="#HTTP-性能" class="headerlink" title="HTTP 性能"></a>HTTP 性能</h4><p>要测试 HTTP 的性能，也有大量的工具可以使用，比如 ab、webbench 等，都是常用的 HTTP 压力测试工具。其中，ab 是 Apache 自带的 HTTP 压测工具，主要测试 HTTP 服务的每秒请求数、请求延迟、吞吐量以及请求延迟的分布情况等。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Ubuntu</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> apt-get install -y apache2-utils</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> CentOS</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> yum install -y httpd-tools</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -c表示并发请求数为1000，-n表示总的请求数为10000</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ab -c 1000 -n 10000 http://192.168.0.30/</span></span><br><span class="line">...</span><br><span class="line">Server Software:        nginx/1.15.8</span><br><span class="line">Server Hostname:        192.168.0.30</span><br><span class="line">Server Port:            80</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Requests per second:    1078.54 [#/sec] (mean)</span><br><span class="line">Time per request:       927.183 [ms] (mean)</span><br><span class="line">Time per request:       0.927 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          890.00 [Kbytes/sec] received</span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">            min  mean[+/-sd] median   max</span><br><span class="line">Connect:        0   27 152.1      1    1038</span><br><span class="line">Processing:     9  207 843.0     22    9242</span><br><span class="line">Waiting:        8  207 843.0     22    9242</span><br><span class="line">Total:         15  233 857.7     23    9268</span><br><span class="line"></span><br><span class="line">Percentage of the requests served within a certain time (ms)</span><br><span class="line"><span class="meta">50%</span><span class="bash">     23</span></span><br><span class="line"><span class="meta">66%</span><span class="bash">     24</span></span><br><span class="line"><span class="meta">75%</span><span class="bash">     24</span></span><br><span class="line"><span class="meta">80%</span><span class="bash">     26</span></span><br><span class="line"><span class="meta">90%</span><span class="bash">    274</span></span><br><span class="line"><span class="meta">95%</span><span class="bash">   1195</span></span><br><span class="line"><span class="meta">98%</span><span class="bash">   2335</span></span><br><span class="line"><span class="meta">99%</span><span class="bash">   4663</span></span><br><span class="line"><span class="meta">100%</span><span class="bash">   9268 (longest request)</span></span><br></pre></td></tr></table></figure>

<h4 id="应用负载性能"><a href="#应用负载性能" class="headerlink" title="应用负载性能"></a>应用负载性能</h4><p>在应用层，我们关注的是应用程序的并发连接数、每秒请求数、处理延迟、错误数等，可以使用 wrk、JMeter 等工具，模拟用户的负载，得到想要的测试结果。</p>
<h3 id="tcpdump-和-Wireshark"><a href="#tcpdump-和-Wireshark" class="headerlink" title="tcpdump 和 Wireshark"></a>tcpdump 和 Wireshark</h3><h4 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> CentOS</span></span><br><span class="line">yum install -y tcpdump wireshark</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump -nn udp port 53 or host 35.190.27.188</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tcpdump -nn udp port 53 or host 35.190.27.188 -w ping.pcap</span></span><br><span class="line"></span><br><span class="line">-nn ，表示不解析抓包中的域名（即不反向解析）、协议以及端口号。</span><br><span class="line">udp port 53 ，表示只显示 UDP 协议的端口号（包括源端口和目的端口）为 53 的包。</span><br><span class="line">host 35.190.27.188 ，表示只显示 IP 地址（包括源地址和目的地址）为 35.190.27.188 的包。</span><br><span class="line">这两个过滤条件中间的“ or ”，表示或的关系，也就是说，只要满足上面两个条件中的任一个，就可以展示出来。</span><br><span class="line"></span><br><span class="line">sudo tcpdump -Z zshield -X -nn &#x27;net 10.240.241.0/24 and port 18081&#x27; -w packet</span><br></pre></td></tr></table></figure>

<img src="/2021/12/21/4-%E7%BD%91%E7%BB%9C/tcpdump%E9%80%89%E9%A1%B9.webp" class="">
<img src="/2021/12/21/4-%E7%BD%91%E7%BB%9C/tcpdump%E8%BF%87%E6%BB%A4%E8%A1%A8%E8%BE%BE%E5%BC%8F.webp" class="">

<p>tcpdump 输出格式：</p>
<p>时间戳 协议 源地址.源端口 &gt; 目的地址.目的端口 网络包详细信息</p>
<h4 id="wireshark"><a href="#wireshark" class="headerlink" title="wireshark"></a>wireshark</h4><img src="/2021/12/21/4-%E7%BD%91%E7%BB%9C/%E6%AD%A3%E5%B8%B8%E5%8C%85.webp" class="">

<p>点击 Statistics -&gt; Flow Graph，然后，在弹出的界面中的 Flow type 选择 TCP Flows，你可以更清晰的看到，整个过程中 TCP 流的执行过程</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> --tcp表示使用TCP协议，-p表示端口号，-n表示不对结果中的IP地址执行反向域名解析</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> traceroute --tcp -p 80 -n baidu.com</span></span><br><span class="line">traceroute to baidu.com (123.125.115.110), 30 hops max, 60 byte packets</span><br><span class="line"> 1  * * *</span><br><span class="line"> 2  * * *</span><br><span class="line"> 3  * * *</span><br><span class="line"> 4  * * *</span><br><span class="line"> 5  * * *</span><br><span class="line"> 6  * * *</span><br><span class="line"> 7  * * *</span><br><span class="line"> 8  * * *</span><br><span class="line"> 9  * * *</span><br><span class="line">10  * * *</span><br><span class="line">11  * * *</span><br><span class="line">12  * * *</span><br><span class="line">13  * * *</span><br><span class="line">14  123.125.115.110  20.684 ms *  20.798 ms</span><br></pre></td></tr></table></figure>

<p>traceroute 会在路由的每一跳发送三个包，并在收到响应后，输出往返延时。如果无响应或者响应超时</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 记录一会（比如30s）后按Ctrl+C结束</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> perf record -a -g -- sleep 30</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出报告</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> perf report -g graph,0</span></span><br></pre></td></tr></table></figure>

<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="根据指标找工具"><a href="#根据指标找工具" class="headerlink" title="根据指标找工具"></a>根据指标找工具</h3><img src="/2021/12/21/4-%E7%BD%91%E7%BB%9C/%E6%8C%87%E6%A0%87%E6%89%BE%E5%B7%A5%E5%85%B7.webp" class="">

<h3 id="根据工具查指标"><a href="#根据工具查指标" class="headerlink" title="根据工具查指标"></a>根据工具查指标</h3><img src="/2021/12/21/4-%E7%BD%91%E7%BB%9C/%E5%B7%A5%E5%85%B7%E6%8C%87%E6%A0%87.webp" class="">

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sk-xinye.github.io/2021/12/19/3-IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sk-xinye">
      <meta itemprop="description" content="愿所有努力都不被辜负">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sk-xinyeの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/19/3-IO/" class="post-title-link" itemprop="url">3.IO</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-19 20:52:59" itemprop="dateCreated datePublished" datetime="2021-12-19T20:52:59+08:00">2021-12-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-21 20:45:11" itemprop="dateModified" datetime="2021-12-21T20:45:11+08:00">2021-12-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>文件系统，本身是对存储设备上的文件，进行组织管理的机制。组织方式不同，就会形成不同的文件系统。</p>
<h3 id="索引节点（index-node）和目录项（directory-entry）"><a href="#索引节点（index-node）和目录项（directory-entry）" class="headerlink" title="索引节点（index node）和目录项（directory entry）"></a>索引节点（index node）和目录项（directory entry）</h3><p>为了方便管理，Linux 文件系统为每个文件都分配两个数据结构，索引节点（index node）和目录项（directory entry）。它们主要用来记录文件的元信息和目录结构。</p>
<ul>
<li>索引节点，简称为 inode，用来记录文件的元数据，比如 inode 编号、文件大小、访问权限、修改日期、数据的位置等。索引节点和文件一一对应，它跟文件内容一样，都会被持久化存储到磁盘中。所以记住，索引节点同样占用磁盘空间。</li>
<li>目录项，简称为 dentry，用来记录文件的名字、索引节点指针以及与其他目录项的关联关系。多个关联的目录项，就构成了文件系统的目录结构。不过，不同于索引节点，目录项是由内核维护的一个内存数据结构，所以通常也被叫做目录项缓存。</li>
</ul>
<p>换句话说，索引节点是每个文件的唯一标志，而目录项维护的正是文件系统的树状结构。目录项和索引节点的关系是多对一，你可以简单理解为，一个文件可以有多个别名。通过硬链接为文件创建的别名，就会对应不同的目录项，不过这些目录项本质上还是链接同一个文件，所以，它们的索引节点相同。</p>
<p>磁盘文件读写最小单位扇区 –为了增加效率将连续的8个扇区组成逻辑块4KB–&gt;逻辑快，操作的就是逻辑块</p>
<img src="/2021/12/19/3-IO/%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8.webp" class="">

<p>注意：</p>
<ul>
<li>第一，目录项本身就是一个内存缓存，而索引节点则是存储在磁盘中的数据。在前面的 Buffer 和 Cache 原理中，我曾经提到过，为了协调慢速磁盘与快速 CPU 的性能差异，文件内容会缓存到页缓存 Cache 中。</li>
<li>第二，磁盘在执行文件系统格式化时，会被分成三个存储区域，超级块、索引节点区和数据块区。其中，<ul>
<li>超级块，存储整个文件系统的状态。</li>
<li>索引节点区，用来存储索引节点。</li>
<li>数据块区，则用来存储文件数据</li>
</ul>
</li>
</ul>
<h3 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h3><p>目录项、索引节点、逻辑块以及超级块，构成了 Linux 文件系统的四大基本要素。不过，为了支持各种不同的文件系统，Linux 内核在用户进程和文件系统的中间，又引入了一个抽象层，也就是虚拟文件系统 VFS（Virtual File System）。</p>
<img src="/2021/12/19/3-IO/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.webp" class="">

<p>分为3类：</p>
<ul>
<li>第一类是基于磁盘的文件系统，也就是把数据直接存储在计算机本地挂载的磁盘中。常见的 Ext4、XFS、OverlayFS 等，都是这类文件系统。</li>
<li>第二类是基于内存的文件系统，也就是我们常说的虚拟文件系统。这类文件-系统，不需要任何磁盘分配存储空间，但会占用内存。我们经常用到的 /proc 文件系统，其实就是一种最常见的虚拟文件系统。此外，/sys 文件系统也属于这一类，主要向用户空间导出层次化的内核对象。</li>
<li>第三类是网络文件系统，也就是用来访问其他计算机数据的文件系统，比如 NFS、SMB、iSCSI 等。</li>
</ul>
<p>这些文件系统，要先挂载到 VFS 目录树中的某个子目录（称为挂载点），然后才能访问其中的文件。拿第一类，也就是基于磁盘的文件系统为例，在安装系统时，要先挂载一个根目录（/），在根目录下再把其他文件系统（比如其他的磁盘分区、/proc 文件系统、/sys 文件系统、NFS 等）挂载进来。</p>
<h3 id="文件系统-I-O"><a href="#文件系统-I-O" class="headerlink" title="文件系统 I/O"></a>文件系统 I/O</h3><p>文件读写方式的各种差异，导致 I/O 的分类多种多样。包括缓冲与非缓冲 I/O、直接与非直接 I/O、阻塞与非阻塞 I/O、同步与异步 I/O 等</p>
<ul>
<li>缓冲与非缓冲 I/O（，根据是否利用标准库缓存，可以把文件 I/O 分为缓冲 I/O 与非缓冲 I/O。）<ul>
<li>缓冲 I/O，是指利用标准库缓存来加速文件的访问，而标准库内部再通过系统调度访问文件。</li>
<li>非缓冲 I/O，是指直接通过系统调用来访问文件，不再经过标准库缓存。</li>
</ul>
</li>
<li>直接与非直接 I/O（根据是否利用操作系统的页缓存，可以把文件 I/O 分为直接 I/O 与非直接 I/O）<ul>
<li>直接 I/O，是指跳过操作系统的页缓存，直接跟文件系统交互来访问文件。</li>
<li>非直接 I/O 正好相反，文件读写时，先要经过系统的页缓存，然后再由内核或额外的系统调用，真正写入磁盘。</li>
</ul>
</li>
<li>阻塞与非阻塞 I/O（根据应用程序是否阻塞自身运行，可以把文件 I/O 分为阻塞 I/O 和非阻塞 I/O）<ul>
<li>所谓阻塞 I/O，是指应用程序执行 I/O 操作后，如果没有获得响应，就会阻塞当前线程，自然就不能执行其他任务。</li>
<li>所谓非阻塞 I/O，是指应用程序执行 I/O 操作后，不会阻塞当前的线程，可以继续执行其他的任务，随后再通过轮询或者事件通知的形式，获取调用的结果。</li>
</ul>
</li>
<li>同步与异步 I/O (根据是否等待响应结果，可以把文件 I/O 分为同步和异步 I/O)<ul>
<li>所谓同步 I/O，是指应用程序执行 I/O 操作后，要一直等到整个 I/O 完成后，才能获得 I/O 响应。</li>
<li>所谓异步 I/O，是指应用程序执行 I/O 操作后，不用等待完成和完成后的响应，而是继续执行就可以。等到这次 I/O 完成后，响应会用事件通知的方式，告诉应用程序。</li>
</ul>
</li>
</ul>
<h3 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> df -h /dev/sda1</span></span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/sda1        29G  3.1G   26G  11% /</span><br><span class="line"></span><br><span class="line">索引节点</span><br><span class="line"><span class="meta">$</span><span class="bash"> df -i /dev/sda1</span></span><br><span class="line">Filesystem      Inodes  IUsed   IFree IUse% Mounted on</span><br><span class="line">/dev/sda1      3870720 157460 3713260    5% /</span><br></pre></td></tr></table></figure>

<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/meminfo | grep -E <span class="string">&quot;SReclaimable|Cached&quot;</span></span></span><br><span class="line">Cached:           748316 kB</span><br><span class="line">SwapCached:            0 kB</span><br><span class="line">SReclaimable:     179508 kB</span><br><span class="line"></span><br><span class="line">在实际性能分析中，我们更常使用 slabtop ，来找到占用内存最多的缓存类型。</span><br><span class="line"><span class="meta">#</span><span class="bash"> 按下c按照缓存大小排序，按下a按照活跃对象数排序</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> slabtop</span></span><br><span class="line">Active / Total Objects (% used)    : 277970 / 358914 (77.4%)</span><br><span class="line">Active / Total Slabs (% used)      : 12414 / 12414 (100.0%)</span><br><span class="line">Active / Total Caches (% used)     : 83 / 135 (61.5%)</span><br><span class="line">Active / Total Size (% used)       : 57816.88K / 73307.70K (78.9%)</span><br><span class="line">Minimum / Average / Maximum Object : 0.01K / 0.20K / 22.88K</span><br><span class="line"></span><br><span class="line">OBJS ACTIVE  USE OBJ SIZE  SLABS OBJ/SLAB CACHE SIZE NAME</span><br><span class="line">69804  23094   0%    0.19K   3324       21     13296K dentry</span><br><span class="line">16380  15854   0%    0.59K   1260       13     10080K inode_cache</span><br><span class="line">58260  55397   0%    0.13K   1942       30      7768K kernfs_node_cache</span><br><span class="line">485    413   0%    5.69K     97        5      3104K task_struct</span><br><span class="line">1472   1397   0%    2.00K     92       16      2944K kmalloc-2048</span><br></pre></td></tr></table></figure>

<h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><p>由文件系统层、通用块层和设备层构成的 Linux 存储系统 I/O 栈。其中，通用块层是 Linux 磁盘 I/O 的核心。向上，它为文件系统和应用程序，提供访问了块设备的标准接口；向下，把各种异构的磁盘设备，抽象为统一的块设备，并会对文件系统和应用程序发来的 I/O 请求进行重新排序、请求合并等，提高了磁盘访问的效率。</p>
<h3 id="磁盘性能指标"><a href="#磁盘性能指标" class="headerlink" title="磁盘性能指标"></a>磁盘性能指标</h3><p>说到磁盘性能的衡量标准，必须要提到五个常见指标，也就是我们经常用到的，使用率、饱和度、IOPS、吞吐量以及响应时间等。这五个指标，是衡量磁盘性能的基本指标。</p>
<ul>
<li>使用率，是指磁盘处理 I/O 的时间百分比。过高的使用率（比如超过 80%），通常意味着磁盘 I/O 存在性能瓶颈。</li>
<li>饱和度，是指磁盘处理 I/O 的繁忙程度。过高的饱和度，意味着磁盘存在严重的性能瓶颈。当饱和度为 100% 时，磁盘无法接受新的 I/O 请求。</li>
<li>IOPS（Input/Output Per Second），是指每秒的 I/O 请求数。</li>
<li>吞吐量，是指每秒的 I/O 请求大小。</li>
<li>响应时间，是指 I/O 请求从发出到收到响应的间隔时间。</li>
</ul>
<p>这里要注意的是，使用率只考虑有没有 I/O，而不考虑 I/O 的大小。换句话说，当使用率是 100% 的时候，磁盘依然有可能接受新的 I/O 请求。</p>
<p>在数据库、大量小文件等这类随机读写比较多的场景中，IOPS 更能反映系统的整体性能；而在多媒体等顺序读写较多的场景中，吞吐量才更能反映系统的整体性能。</p>
<h3 id="磁盘-I-O-观测"><a href="#磁盘-I-O-观测" class="headerlink" title="磁盘 I/O 观测"></a>磁盘 I/O 观测</h3><p>iostat 是最常用的磁盘 I/O 性能观测工具，它提供了每个磁盘的使用率、IOPS、吞吐量等各种常见的性能指标，当然，这些指标实际上来自 /proc/diskstats。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -d表示显示I/O性能指标，-x表示显示扩展统计（即所有I/O指标）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iostat -d -x 1</span></span><br><span class="line">Device            r/s     w/s     rkB/s     wkB/s   rrqm/s   wrqm/s  %rrqm  %wrqm r_await w_await aqu-sz rareq-sz wareq-sz  svctm  %util</span><br><span class="line">loop0            0.00    0.00      0.00      0.00     0.00     0.00   0.00   0.00    0.00    0.00   0.00     0.00     0.00   0.00   0.00</span><br><span class="line">loop1            0.00    0.00      0.00      0.00     0.00     0.00   0.00   0.00    0.00    0.00   0.00     0.00     0.00   0.00   0.00</span><br><span class="line">sda              0.00    0.00      0.00      0.00     0.00     0.00   0.00   0.00    0.00    0.00   0.00     0.00     0.00   0.00   0.00</span><br><span class="line">sdb              0.00    0.00      0.00      0.00     0.00     0.00   0.00   0.00    0.00    0.00   0.00     0.00     0.00   0.00   0.00</span><br></pre></td></tr></table></figure>

<ul>
<li>%util ，就是我们前面提到的磁盘 I/O 使用率；</li>
<li>r/s+ w/s ，就是 IOPS；</li>
<li>rkB/s+wkB/s ，就是吞吐量；</li>
<li>r_await+w_await ，就是响应时间.</li>
</ul>
<h3 id="进程-I-O-观测"><a href="#进程-I-O-观测" class="headerlink" title="进程 I/O 观测"></a>进程 I/O 观测</h3><p>pidstat iptop</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pidstat -d 1</span></span><br><span class="line">13:39:51      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command</span><br><span class="line">13:39:52      102       916      0.00      4.00      0.00       0  rsyslogd</span><br></pre></td></tr></table></figure>

<ul>
<li>用户 ID（UID）和进程 ID（PID） 。</li>
<li>每秒读取的数据大小（kB_rd/s） ，单位是 KB。</li>
<li>每秒发出的写请求数据大小（kB_wr/s） ，单位是 KB。</li>
<li>每秒取消的写请求数据大小（kB_ccwr/s） ，单位是 KB。</li>
<li>块 I/O 延迟（iodelay），包括等待同步块 I/O 和换入块 I/O 结束的时间，单位是时钟周期。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> iotop</span></span><br><span class="line">Total DISK READ :       0.00 B/s | Total DISK WRITE :       7.85 K/s</span><br><span class="line">Actual DISK READ:       0.00 B/s | Actual DISK WRITE:       0.00 B/s</span><br><span class="line">TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO&gt;    COMMAND</span><br><span class="line">15055 be/3 root        0.00 B/s    7.85 K/s  0.00 %  0.00 % systemd-journald</span><br></pre></td></tr></table></figure>

<ul>
<li>从这个输出，你可以看到，前两行分别表示，进程的磁盘读写大小总数和磁盘真实的读写大小总数。因为缓存、缓冲区、I/O 合并等因素的影响，它们可能并不相等。</li>
<li>剩下的部分，则是从各个角度来分别表示进程的 I/O 情况，包括线程 ID、I/O 优先级、每秒读磁盘的大小、每秒写磁盘的大小、换入和等待 I/O 的时钟百分比等。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">分析系统调用时用的工具</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> strace -p 18940</span></span><br><span class="line">strace: Process 18940 attached</span><br><span class="line">...</span><br><span class="line">mmap(NULL, 314576896, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f0f7aee9000</span><br><span class="line">mmap(NULL, 314576896, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f0f682e8000</span><br><span class="line">write(3, &quot;2018-12-05 15:23:01,709 - __main&quot;..., 314572844</span><br><span class="line">) = 314572844</span><br><span class="line">munmap(0x7f0f682e8000, 314576896)       = 0</span><br><span class="line">write(3, &quot;\n&quot;, 1)                       = 1</span><br><span class="line">munmap(0x7f0f7aee9000, 314576896)       = 0</span><br><span class="line">close(3)                                = 0</span><br><span class="line">stat(&quot;/tmp/logtest.txt.1&quot;, &#123;st_mode=S_IFREG|0644, st_size=943718535, ...&#125;) = 0</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lsof。它专门用来查看进程打开文件列表，不过，这里的“文件”不只有普通文件，还包括了目录、块设备、动态库、网络套接字等。</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> lsof -p 18940</span></span><br><span class="line">COMMAND   PID USER   FD   TYPE DEVICE  SIZE/OFF    NODE NAME</span><br><span class="line">python  18940 root  cwd    DIR   0,50      4096 1549389 /</span><br><span class="line">python  18940 root  rtd    DIR   0,50      4096 1549389 /</span><br><span class="line">…</span><br><span class="line">python  18940 root    2u   CHR  136,0       0t0       3 /dev/pts/0</span><br><span class="line">python  18940 root    3w   REG    8,1 117944320     303 /tmp/logtest.txt</span><br></pre></td></tr></table></figure>

<ul>
<li>FD 表示文件描述符号</li>
<li>TYPE 表示文件类型</li>
<li>NAME 表示文件路径</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">案例27</span><br><span class="line">filetop。它是 bcc 软件包的一部分，基于 Linux 内核的 eBPF（extended Berkeley Packet Filters）机制，主要跟踪内核中文件的读写情况，并输出线程 ID（TID）、读写大小、读写类型以及文件名称。</span><br><span class="line">pensnoop 。它同属于 bcc 软件包，可以动态跟踪内核中的 open 系统调用。这样，我们就可以找出这些 txt 文件的路径。</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> opensnoop</span></span><br><span class="line">12280  python              6   0 /tmp/9046db9e-fe25-11e8-b13f-0242ac110002/650.txt</span><br><span class="line">12280  python              6   0 /tmp/9046db9e-fe25-11e8-b13f-0242ac110002/651.txt</span><br><span class="line">12280  python              6   0 /tmp/9046db9e-fe25-11e8-b13f-0242ac110002/652.txt</span><br></pre></td></tr></table></figure>

<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><img src="/2021/12/19/3-IO/io%E6%A0%88.webp" class="">

<ul>
<li>首先，最容易想到的是存储空间的使用情况，包括容量、使用量以及剩余空间等 容易忽略的是索引节点的使用情况，它也包括容量、使用量以及剩余量等三个指标。</li>
<li>其次，你应该想到的是前面多次提到过的缓存使用情况，包括页缓存、目录项缓存、索引节点缓存以及各个具体文件系统（如 ext4、XFS 等）的缓存。</li>
</ul>
<img src="/2021/12/19/3-IO/io%E6%8C%87%E6%A0%87.webp" class="">

<h3 id="根据指标找工具"><a href="#根据指标找工具" class="headerlink" title="根据指标找工具"></a>根据指标找工具</h3><img src="/2021/12/19/3-IO/%E6%8C%87%E6%A0%87%E6%89%BE%E5%B7%A5%E5%85%B7.webp" class="">

<h3 id="根据工具查指标"><a href="#根据工具查指标" class="headerlink" title="根据工具查指标"></a>根据工具查指标</h3><img src="/2021/12/19/3-IO/%E5%B7%A5%E5%85%B7%E6%8C%87%E6%A0%87.webp" class="">

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul>
<li>先用 iostat 发现磁盘 I/O 性能瓶颈；</li>
<li>再借助 pidstat ，定位出导致瓶颈的进程；</li>
<li>随后分析进程的 I/O 行为；</li>
<li>最后，结合应用程序的原理，分析这些 I/O 的来源。</li>
</ul>
<p>所以，为了缩小排查范围，我通常会先运行那几个支持指标较多的工具，如 iostat、vmstat、pidstat 等。</p>
<img src="/2021/12/19/3-IO/io%E5%88%86%E6%9E%90%E6%B5%81%E7%A8%8B.webp" class="">

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sk-xinye.github.io/2021/12/19/2-%E5%86%85%E5%AD%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sk-xinye">
      <meta itemprop="description" content="愿所有努力都不被辜负">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sk-xinyeの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/19/2-%E5%86%85%E5%AD%98/" class="post-title-link" itemprop="url">2.内存</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-19 19:16:11" itemprop="dateCreated datePublished" datetime="2021-12-19T19:16:11+08:00">2021-12-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-04 10:33:07" itemprop="dateModified" datetime="2023-02-04T10:33:07+08:00">2023-02-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><h3 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h3><p>只有内核可以访问物理内存，进程只能访问虚拟内存。</p>
<p>内存映射，其实就是将虚拟内存地址映射到物理内存地址。为了完成内存映射，内核为每个进程都维护了一张页表，记录虚拟地址与物理地址的映射关系，如下图所示：</p>
<img src="/2021/12/19/2-%E5%86%85%E5%AD%98/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84.webp" class="">

<ul>
<li>页表实际上存储在 CPU 的内存管理单元 MMU 中，这样，正常情况下，处理器就可以直接通过硬件，找出要访问的内存。</li>
<li>而当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。</li>
<li>虚拟内存还通过多级页表和大页（HugePage）解决页表项过多的问题</li>
</ul>
<h3 id="虚拟内存空间分布"><a href="#虚拟内存空间分布" class="headerlink" title="虚拟内存空间分布"></a>虚拟内存空间分布</h3><img src="/2021/12/19/2-%E5%86%85%E5%AD%98/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%88%86%E5%B8%83.webp" class="">

<p>通过这张图你可以看到，用户空间内存，从低到高分别是五种不同的内存段。</p>
<ul>
<li>只读段，包括代码和常量等。</li>
<li>数据段，包括全局变量等。</li>
<li>堆，包括动态分配的内存，从低地址开始向上增长。</li>
<li>文件映射段，包括动态库、共享内存等，从高地址开始向下增长。</li>
<li>栈，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8 MB。</li>
</ul>
<p>在这五个内存段中，堆和文件映射段的内存是动态分配的。比如说，使用 C 标准库的 malloc() 或者 mmap() ，就可以分别在堆和文件映射段动态分配内存。</p>
<h3 id="内存分配与回收"><a href="#内存分配与回收" class="headerlink" title="内存分配与回收"></a>内存分配与回收</h3><p>malloc() 是 C 标准库提供的内存分配函数，对应到系统调用上，有两种实现方式，即 brk() 和 mmap()。当进程通过 malloc() 申请内存后，内存并不会立即分配，而是在首次访问时，才通过缺页异常陷入内核中分配内存。</p>
<p>对小块内存（小于 128K），C 标准库使用 brk() 来分配，也就是通过移动堆顶的位置来分配内存。这些内存释放后并不会立刻归还系统，而是被缓存起来，这样就可以重复使用。<br>而大块内存（大于 128K），则直接使用内存映射 mmap() 来分配，也就是在文件映射段找一块空闲内存分配出去。</p>
<p>在发现内存紧张时，系统就会通过一系列机制来回收内存，比如下面这三种方式：</p>
<ul>
<li>回收缓存，比如使用 LRU（Least Recently Used）算法，回收最近使用最少的内存页面；</li>
<li>回收不常访问的内存，把不常用的内存通过交换分区直接写到磁盘中；</li>
<li>杀死进程，内存紧张时系统还会通过 OOM（Out of Memory），直接杀掉占用大量内存的进程。<ul>
<li>一个进程消耗的内存越大，oom_score 就越大；</li>
<li>一个进程运行占用的 CPU 越多，oom_score 就越小。</li>
<li>echo -16 &gt; /proc/$(pidof sshd)/oom_adj</li>
</ul>
</li>
</ul>
<h3 id="如何查看内存使用情况"><a href="#如何查看内存使用情况" class="headerlink" title="如何查看内存使用情况"></a>如何查看内存使用情况</h3><p>free:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 注意不同版本的free输出可能会有所不同</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> free</span></span><br><span class="line">            total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:        8169348      263524     6875352         668     1030472     7611064</span><br><span class="line">Swap:             0           0           0</span><br><span class="line"></span><br><span class="line">第一列，total 是总内存大小；</span><br><span class="line">第二列，used 是已使用内存的大小，包含了共享内存；</span><br><span class="line">第三列，free 是未使用内存的大小；</span><br><span class="line">第四列，shared 是共享内存的大小；</span><br><span class="line">第五列，buff/cache 是缓存和缓冲区的大小；</span><br><span class="line">最后一列，available 是新进程可用内存的大小。</span><br><span class="line"></span><br><span class="line">pidstat -r -p 123123</span><br><span class="line">查看进程内存占用情况 包括rss 及vfs</span><br></pre></td></tr></table></figure>

<p>top:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 按下M切换到内存排序</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> top</span></span><br><span class="line">...</span><br><span class="line">KiB Mem :  8169348 total,  6871440 free,   267096 used,  1030812 buff/cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used.  7607492 avail Mem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">430 root      19  -1  122360  35588  23748 S   0.0  0.4   0:32.17 systemd-journal</span><br><span class="line">1075 root      20   0  771860  22744  11368 S   0.0  0.3   0:38.89 snapd</span><br><span class="line">1048 root      20   0  170904  17292   9488 S   0.0  0.2   0:00.24 networkd-dispat</span><br><span class="line">    1 root      20   0   78020   9156   6644 S   0.0  0.1   0:22.92 systemd</span><br><span class="line">12376 azure     20   0   76632   7456   6420 S   0.0  0.1   0:00.01 systemd</span><br><span class="line">12374 root      20   0  107984   7312   6304 S   0.0  0.1   0:00.00 sshd</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">VIRT 是进程虚拟内存的大小，只要是进程申请过的内存，即便还没有真正分配物理内存，也会计算在内。</span><br><span class="line">RES 是常驻内存的大小，也就是进程实际使用的物理内存大小，但不包括 Swap 和共享内存。</span><br><span class="line">SHR 是共享内存的大小，比如与其他进程共同使用的共享内存、加载的动态链接库以及程序的代码段等。</span><br><span class="line"><span class="meta">%</span><span class="bash">MEM 是进程使用物理内存占系统总内存的百分比。</span></span><br></pre></td></tr></table></figure>

<h3 id="buffer-与cache"><a href="#buffer-与cache" class="headerlink" title="buffer 与cache"></a>buffer 与cache</h3><ul>
<li>Buffers 是对原始磁盘块的临时存储，也就是用来缓存磁盘的数据，通常不会特别大（20MB 左右）。这样，内核就可以把分散的写集中起来，统一优化磁盘的写入，比如可以把多次小的写合并成单次大的写等等。</li>
<li>Cached 是从磁盘读取文件的页缓存，也就是用来缓存从文件读取的数据。这样，下次访问这些文件数据时，就可以直接从内存中快速获取，而不需要再次访问缓慢的磁盘。</li>
<li>SReclaimable 是 Slab 的一部分。Slab 包括两部分，其中的可回收部分，用 SReclaimable 记录；而不可回收部分，用 SUnreclaim 记录。 slabtop</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 清理文件页、目录项、Inodes等各种缓存</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> 3 &gt; /proc/sys/vm/drop_caches</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 首先清理缓存</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> 3 &gt; /proc/sys/vm/drop_caches</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后运行dd命令向磁盘分区/dev/sdb1写入2G数据</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> dd <span class="keyword">if</span>=/dev/urandom of=/dev/sdb1 bs=1M count=2048</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 每隔1秒输出1组数据</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vmstat 1</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line">r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line">0  0      0 7743608   1112  92168    0    0     0     0   52  152  0  1 100  0  0</span><br><span class="line">0  0      0 7743608   1112  92168    0    0     0     0   36   92  0  0 100  0  0</span><br><span class="line">buff 和 cache 就是我们前面看到的 Buffers 和 Cache，单位是 KB。</span><br><span class="line">bi 和 bo 则分别表示块设备读取和写入的大小，单位为块 / 秒。因为 Linux 中块的大小是 1KB，所以这个单位也就等价于 KB/s。</span><br><span class="line"></span><br><span class="line">写文件时会用到 Cache 缓存数据，而写磁盘则会用到 Buffer 来缓存数据。所以，回到刚刚的问题，虽然文档上只提到，Cache 是文件读的缓存，但实际上，Cache 也会缓存写文件时的数据。</span><br></pre></td></tr></table></figure>

<p>Buffer 是对磁盘数据的缓存，而 Cache 是文件数据的缓存，它们既会用在读请求中，也会用在写请求中。</p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>cachestat 和 cachetop ，它们正是查看系统缓存命中情况的工具。这两个工具都是 bcc 软件包的一部分，它们基于 Linux 内核的 eBPF（extended Berkeley Packet Filters）机制，来跟踪内核中管理的缓存，并输出缓存的使用和命中情况。在17中</p>
<p>内存泄露分析工具（memleak 是 bcc 软件包中的一个工具）18</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memleak -a -p &lt;pid&gt;   kmemoryleak</span><br></pre></td></tr></table></figure>

<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><img src="/2021/12/19/2-%E5%86%85%E5%AD%98/%E5%86%85%E5%AD%98%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87.webp" class="">

<h3 id="根据指标找工具"><a href="#根据指标找工具" class="headerlink" title="根据指标找工具"></a>根据指标找工具</h3><img src="/2021/12/19/2-%E5%86%85%E5%AD%98/%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E6%89%BE%E5%B7%A5%E5%85%B7.webp" class="">

<h3 id="根据工具查指标"><a href="#根据工具查指标" class="headerlink" title="根据工具查指标"></a>根据工具查指标</h3><img src="/2021/12/19/2-%E5%86%85%E5%AD%98/%E5%B7%A5%E5%85%B7%E6%89%BE%E6%8C%87%E6%A0%87.webp" class="">

<h3 id="分析流程"><a href="#分析流程" class="headerlink" title="分析流程"></a>分析流程</h3><img src="/2021/12/19/2-%E5%86%85%E5%AD%98/%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%E6%B5%81%E7%A8%8B.webp" class="">

<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ul>
<li>最好禁止 Swap（swapoff -a）。如果必须开启 Swap，降低 swappiness 的值，减少内存回收时 Swap 的使用倾向。</li>
<li>减少内存的动态分配。比如，可以使用内存池、大页（HugePage）等。</li>
<li>尽量使用缓存和缓冲区来访问数据。比如，可以使用堆栈明确声明内存空间，来存储需要缓存的数据；或者用 Redis 这类的外部缓存组件，优化数据的访问。</li>
<li>使用 cgroups 等方式限制进程的内存使用情况。这样，可以确保系统内存不会被异常进程耗尽。</li>
<li>通过 /proc/pid/oom_adj ，调整核心应用的 oom_score。这样，可以保证即使内存紧张，核心应用也不会被 OOM 杀死。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sk-xinye.github.io/2021/12/16/1-cpu%E6%80%A7%E8%83%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sk-xinye">
      <meta itemprop="description" content="愿所有努力都不被辜负">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sk-xinyeの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/16/1-cpu%E6%80%A7%E8%83%BD/" class="post-title-link" itemprop="url">1.cpu性能</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-16 17:00:46" itemprop="dateCreated datePublished" datetime="2021-12-16T17:00:46+08:00">2021-12-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-04 10:33:07" itemprop="dateModified" datetime="2023-02-04T10:33:07+08:00">2023-02-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="性能工具"><a href="#性能工具" class="headerlink" title="性能工具"></a>性能工具</h2><h3 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> uptime</span></span><br><span class="line">02:34:03 up 2 days, 20:14,  1 user,  load average: 0.63, 0.83, 0.88</span><br><span class="line">当前时间     系统运行时间  正在登陆用户      1分钟 5分钟  15分钟平均负载（load average）</span><br></pre></td></tr></table></figure>

<h3 id="stress-mpstat-pidstat"><a href="#stress-mpstat-pidstat" class="headerlink" title="stress mpstat pidstat"></a>stress mpstat pidstat</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">cpu 密集型排查</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> stress --cpu 1 --timeout 600</span></span><br><span class="line">stress 是一个 Linux 系统压力测试工具，这里我们用作异常进程模拟平均负载升高的场景。</span><br><span class="line">sysstat 包含了常用的 Linux 性能工具，用来监控和分析系统的性能。</span><br><span class="line">我们的案例会用到这个包的两个命令 mpstat 和 pidstat。</span><br><span class="line">mpstat 是一个常用的多核 CPU 性能分析工具，用来实时查看每个 CPU 的性能指标，以及所有 CPU 的平均指标。</span><br><span class="line">pidstat 是一个常用的进程性能分析工具，用来实时查看进程的 CPU、内存、I/O 以及上下文切换等性能指标。</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -d 参数表示高亮显示变化的区域</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> watch -d uptime</span></span><br><span class="line">...,  load average: 1.00, 0.75, 0.39</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -P ALL 表示监控所有CPU，后面数字5表示间隔5秒后输出一组数据</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mpstat -P ALL 5</span></span><br><span class="line">Linux 4.15.0 (ubuntu) 09/22/18 _x86_64_ (2 CPU)</span><br><span class="line">13:30:06     CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span><br><span class="line">13:30:11     all   50.05    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00   49.95</span><br><span class="line">13:30:11       0    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00</span><br><span class="line">13:30:11       1  100.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 间隔5秒后输出一组数据</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pidstat -u 5 1</span></span><br><span class="line">13:37:07      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command</span><br><span class="line">13:37:12        0      2962  100.00    0.00    0.00    0.00  100.00     1  stress</span><br><span class="line">从这里可以明显看到，stress 进程的 CPU 使用率为 100%</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">I/O密集型排查</span><br><span class="line"><span class="meta">$</span><span class="bash"> stress -i 1 --timeout 600</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> watch -d uptime</span></span><br><span class="line">...,  load average: 1.06, 0.58, 0.37</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示所有CPU的指标，并在间隔5秒输出一组数据</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mpstat -P ALL 5 1</span></span><br><span class="line">Linux 4.15.0 (ubuntu)     09/22/18     _x86_64_    (2 CPU)</span><br><span class="line">13:41:28     CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span><br><span class="line">13:41:33     all    0.21    0.00   12.07   32.67    0.00    0.21    0.00    0.00    0.00   54.84</span><br><span class="line">13:41:33       0    0.43    0.00   23.87   67.53    0.00    0.43    0.00    0.00    0.00    7.74</span><br><span class="line">13:41:33       1    0.00    0.00    0.81    0.20    0.00    0.00    0.00    0.00    0.00   98.99</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 间隔5秒后输出一组数据，-u表示CPU指标</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pidstat -u 5 1 -d</span></span><br><span class="line">Linux 4.15.0 (ubuntu)     09/22/18     _x86_64_    (2 CPU)</span><br><span class="line">13:42:08      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command</span><br><span class="line">13:42:13        0       104    0.00    3.39    0.00    0.00    3.39     1  kworker/1:1H</span><br><span class="line">13:42:13        0       109    0.00    0.40    0.00    0.00    0.40     0  kworker/0:1H</span><br><span class="line">13:42:13        0      2997    2.00   35.53    0.00    3.99   37.52     1  stress</span><br><span class="line">13:42:13        0      3057    0.00    0.40    0.00    0.00    0.40     0  pidstat</span><br></pre></td></tr></table></figure>

<h3 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vmstat 是一个常用的系统性能分析工具，主要用来分析系统的内存使用情况，也常用来分析 CPU 上下文切换和中断的次数。</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 每隔5秒输出1组数据</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vmstat 5</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line">r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line">0  0      0 7005360  91564 818900    0    0     0     0   25   33  0  0 100  0  0</span><br><span class="line">cs（context switch）是每秒上下文切换的次数。</span><br><span class="line">in（interrupt）则是每秒中断的次数。</span><br><span class="line">r（Running or Runnable）是就绪队列的长度，也就是正在运行和等待 CPU 的进程数。</span><br><span class="line">b（Blocked）则是处于不可中断睡眠状态的进程数。</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 每隔5秒输出1组数据 加 -t显示线程</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pidstat -w 5</span></span><br><span class="line">Linux 4.15.0 (ubuntu)  09/23/18  _x86_64_  (2 CPU)</span><br><span class="line"></span><br><span class="line">08:18:26      UID       PID   cswch/s nvcswch/s  Command</span><br><span class="line">08:18:31        0         1      0.20      0.00  systemd</span><br><span class="line">08:18:31        0         8      5.40      0.00  rcu_sched</span><br></pre></td></tr></table></figure>

<h3 id="ab测试工具"><a href="#ab测试工具" class="headerlink" title="ab测试工具"></a>ab测试工具</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 并发100个请求测试Nginx性能，总共测试1000个请求</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ab -c 100 -n 1000 http://192.168.0.10:10000/</span></span><br><span class="line">This is ApacheBench, Version 2.3 &lt;$Revision: 1706008 $&gt;</span><br><span class="line">Copyright 1996 Adam Twiss, Zeus Technology Ltd,</span><br><span class="line">...</span><br><span class="line">Requests per second:    87.86 [#/sec] (mean)</span><br><span class="line">Time per request:       1138.229 [ms] (mean)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="perf-工具"><a href="#perf-工具" class="headerlink" title="perf 工具"></a>perf 工具</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">perf 工具使用 见5 6</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -g 开启调用关系，-p指定进程号</span></span><br><span class="line">pref top -g -p 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看使用最多的函数</span></span><br><span class="line">perf top</span><br><span class="line"><span class="meta">#</span><span class="bash"> 记录性能事件，等待大约15秒后按 Ctrl+C 退出</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> perf record -g</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看报告</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> perf report</span></span><br><span class="line"></span><br><span class="line">短时进程</span><br><span class="line"><span class="meta">#</span><span class="bash"> 按 Ctrl+C 结束</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> execsnoop</span></span><br><span class="line">PCOMM            PID    PPID   RET ARGS</span><br><span class="line">sh               30394  30393    0</span><br><span class="line">stress           30396  30394    0 /usr/local/bin/stress -t 1 -d 1</span><br><span class="line">sh               30398  30393    0</span><br><span class="line">stress           30399  30398    0 /usr/local/bin/stress -t 1 -d 1</span><br><span class="line">sh               30402  30400    0</span><br><span class="line">stress           30403  30402    0 /usr/local/bin/stress -t 1 -d 1</span><br><span class="line">sh               30405  30393    0</span><br><span class="line">stress           30407  30405    0 /usr/local/bin/stress -t 1 -d 1</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="pidstat"><a href="#pidstat" class="headerlink" title="pidstat"></a>pidstat</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IO wait 较高时</span><br><span class="line"><span class="meta">#</span><span class="bash"> -d 展示 I/O 统计数据，-p 指定进程号，间隔 1 秒输出 3 组数据</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pidstat -d -p 4344 1 3</span></span><br><span class="line">06:38:50      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command</span><br><span class="line">06:38:51        0      4344      0.00      0.00      0.00       0  app</span><br><span class="line">06:38:52        0      4344      0.00      0.00      0.00       0  app</span><br><span class="line">06:38:53        0      4344      0.00      0.00      0.00       0  app</span><br></pre></td></tr></table></figure>

<h3 id="dstat"><a href="#dstat" class="headerlink" title="dstat"></a>dstat</h3><p>dstat ，它的好处是，可以同时查看 CPU 和 I/O 这两种资源的使用情况，便于对比分析。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 间隔1秒输出10组数据</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> dstat 1 10</span></span><br><span class="line">You did not select any stats, using -cdngy by default.</span><br><span class="line">--total-cpu-usage-- -dsk/total- -net/total- ---paging-- ---system--</span><br><span class="line">usr sys idl wai stl| read  writ| recv  send|  in   out | int   csw</span><br><span class="line">  0   0  96   4   0|1219k  408k|   0     0 |   0     0 |  42   885</span><br><span class="line">  0   0   2  98   0|  34M    0 | 198B  790B|   0     0 |  42   138</span><br><span class="line">  0   0   0 100   0|  34M    0 |  66B  342B|   0     0 |  42   135</span><br><span class="line">  0   0  84  16   0|5633k    0 |  66B  342B|   0     0 |  52   177</span><br><span class="line">  0   3  39  58   0|  22M    0 |  66B  342B|   0     0 |  43   144</span><br><span class="line">  0   0   0 100   0|  34M    0 | 200B  450B|   0     0 |  46   147</span><br><span class="line">  0   0   2  98   0|  34M    0 |  66B  342B|   0     0 |  45   134</span><br><span class="line">  0   0   0 100   0|  34M    0 |  66B  342B|   0     0 |  39   131</span><br><span class="line">  0   0  83  17   0|5633k    0 |  66B  342B|   0     0 |  46   168</span><br><span class="line">  0   3  39  59   0|  22M    0 |  66B  342B|   0     0 |  37   134</span><br><span class="line"></span><br><span class="line">  可以看到每当 iowait 升高（wai）时，磁盘的读请求（read）都会很大。这说明 iowait 的升高跟磁盘的读请求有关，很可能就是磁盘读导致的。</span><br></pre></td></tr></table></figure>

<h3 id="sar-tcpdump"><a href="#sar-tcpdump" class="headerlink" title="sar tcpdump"></a>sar tcpdump</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sar 可以用来查看系统的网络收发情况，还有一个好处是，不仅可以观察网络收发的吞吐量（BPS，每秒收发的字节数），还可以观察网络收发的 PPS，即每秒收发的网络帧数。</span><br><span class="line"><span class="meta">#</span><span class="bash"> -n DEV 表示显示网络收发的报告，间隔1秒输出一组数据</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sar -n DEV 1</span></span><br><span class="line">15:03:46        IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil</span><br><span class="line">15:03:47         eth0  12607.00   6304.00    664.86    358.11      0.00      0.00      0.00      0.01</span><br><span class="line">15:03:47      docker0   6302.00  12604.00    270.79    664.66      0.00      0.00      0.00      0.00</span><br><span class="line">15:03:47           lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">15:03:47    veth9f6bbcd   6302.00  12604.00    356.95    664.66      0.00      0.00      0.00      0.05、</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -i eth0 只抓取eth0网卡，-n不解析协议名和主机名</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> tcp port 80表示只抓取tcp协议并且端口号为80的网络帧</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tcpdump -i eth0 -n tcp port 80</span></span><br><span class="line">15:11:32.678966 IP 192.168.0.2.18238 &gt; 192.168.0.30.80: Flags [S], seq 458303614, win 512, length 0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p><strong>平均负载：</strong>是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数，它和 CPU 使用率并没有直接关系。<br><strong>可运行状态进程：</strong>是指正在使用 CPU 或者正在等待 CPU 的进程，也就是我们常用 ps 命令看到的，处于 R 状态（Running 或 Runnable）的进程。<br><strong>不可中断状态进程：</strong>是指正处于内核态关键流程中的进程，并且这些流程是不可打断的，比如最常见的是等待硬件设备的 I/O 响应，也就是我们在 ps 命令中看到的 D 状态（Uninterruptible Sleep，也称为 Disk Sleep）的进程。<br><strong>cpu上下文：</strong>CPU 寄存器，是 CPU 内置的容量小、但速度极快的内存。而程序计数器，则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。它们都是 CPU 在运行任何任务前，必须的依赖环境<br><strong>CPU 上下文切换：</strong>就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。包括<strong>进程上下文切换、线程上下文切换以及中断上下文切换。一次系统调用的过程，其实是发生了两次 CPU 上下文切换，用户态到内核态，内核态到用户态</strong></p>
<p>一次系统调用的过程，其实是发生了两次 CPU 上下文切换</p>
<h2 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h2><h3 id="平均负载"><a href="#平均负载" class="headerlink" title="平均负载"></a>平均负载</h3><p>对于应用负载最理想的，就是每个 CPU 上都刚好运行着一个进程  即对于2c的系统，load average 最好为2</p>
<p>首先你要知道系统有几个 CPU，这可以通过 top 命令或者从文件 /proc/cpuinfo 中读取，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 关于grep和wc的用法请查询它们的手册或者网络搜索</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep <span class="string">&#x27;model name&#x27;</span> /proc/cpuinfo | wc -l</span></span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p><strong>当平均负载高于 CPU 数量 70% 的时候</strong>，你就应该分析排查负载高的问题了。一旦负载过高，就可能导致进程响应变慢，进而影响服务的正常功能。</p>
<h3 id="平均负载与-CPU-使用率"><a href="#平均负载与-CPU-使用率" class="headerlink" title="平均负载与 CPU 使用率"></a>平均负载与 CPU 使用率</h3><p><strong>平均负载：</strong>不仅包括了正在使用 CPU 的进程，还包括等待 CPU 和等待 I/O 的进程。<br><strong>CPU 使用率:</strong> 是单位时间内 CPU 繁忙情况的统计，跟平均负载并不一定完全对应。比如:<br>    - CPU 密集型进程，使用大量 CPU 会导致平均负载升高，此时这两者是一致的；<br>    - I/O 密集型进程，等待 I/O 也会导致平均负载升高，但 CPU 使用率不一定很高；<br>    - 大量等待 CPU 的进程调度也会导致平均负载升高，此时的 CPU 使用率也会比较高。</p>
<h3 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h3><p>无法获取资源而导致的自愿上下文切换；<br>被系统强制调度导致的非自愿上下文切换。</p>
<h3 id="CPU-缓存的命中率"><a href="#CPU-缓存的命中率" class="headerlink" title="CPU 缓存的命中率"></a>CPU 缓存的命中率</h3><img src="/2021/12/16/1-cpu%E6%80%A7%E8%83%BD/cpu%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87.webp" class="">

<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="根据指标找工具"><a href="#根据指标找工具" class="headerlink" title="根据指标找工具"></a>根据指标找工具</h3><img src="/2021/12/16/1-cpu%E6%80%A7%E8%83%BD/cpu%E6%80%A7%E8%83%BD%E5%B7%A5%E5%85%B7.webp" class="">

<h3 id="根据工具查指标"><a href="#根据工具查指标" class="headerlink" title="根据工具查指标"></a>根据工具查指标</h3><img src="/2021/12/16/1-cpu%E6%80%A7%E8%83%BD/%E5%B7%A5%E5%85%B7%E6%8C%87%E6%A0%87.webp" class="">

<h3 id="分析流程"><a href="#分析流程" class="headerlink" title="分析流程"></a>分析流程</h3><img src="/2021/12/16/1-cpu%E6%80%A7%E8%83%BD/cpu%E5%88%86%E6%9E%90%E6%B5%81%E7%A8%8B.webp" class="">

<h2 id="CPU-优化"><a href="#CPU-优化" class="headerlink" title="CPU 优化"></a>CPU 优化</h2><h3 id="应用程序优化"><a href="#应用程序优化" class="headerlink" title="应用程序优化"></a>应用程序优化</h3><p>编译器优化：很多编译器都会提供优化选项，适当开启它们，在编译阶段你就可以获得编译器的帮助，来提升性能。比如， gcc 就提供了优化选项 -O2，开启后会自动对应用程序的代码进行优化。<br>算法优化：使用复杂度更低的算法，可以显著加快处理速度。比如，在数据比较大的情况下，可以用 O(nlogn) 的排序算法（如快排、归并排序等），代替 O(n^2) 的排序算法（如冒泡、插入排序等）。<br>异步处理：使用异步处理，可以避免程序因为等待某个资源而一直阻塞，从而提升程序的并发处理能力。比如，把轮询替换为事件通知，就可以避免轮询耗费 CPU 的问题。<br>多线程代替多进程：前面讲过，相对于进程的上下文切换，线程的上下文切换并不切换进程地址空间，因此可以降低上下文切换的成本。<br>善用缓存：经常访问的数据或者计算过程中的步骤，可以放到内存中缓存起来，这样在下次用时就能直接从内存中获取，加快程序的处理速度。</p>
<h3 id="系统优化"><a href="#系统优化" class="headerlink" title="系统优化"></a>系统优化</h3><p>CPU 绑定：把进程绑定到一个或者多个 CPU 上，可以提高 CPU 缓存的命中率，减少跨 CPU 调度带来的上下文切换问题。<br>CPU 独占：跟 CPU 绑定类似，进一步将 CPU 分组，并通过 CPU 亲和性机制为其分配进程。这样，这些 CPU 就由指定的进程独占，换句话说，不允许其他进程再来使用这些 CPU。<br>优先级调整：使用 nice 调整进程的优先级，正值调低优先级，负值调高优先级。优先级的数值含义前面我们提到过，忘了的话及时复习一下。在这里，适当降低非核心应用的优先级，增高核心应用的优先级，可以确保核心应用得到优先处理。<br>为进程设置资源限制：使用 Linux cgroups 来设置进程的 CPU 使用上限，可以防止由于某个应用自身的问题，而耗尽系统资源。<br>NUMA（Non-Uniform Memory Access）优化：支持 NUMA 的处理器会被划分为多个 node，每个 node 都有自己的本地内存空间。NUMA 优化，其实就是让 CPU 尽可能只访问本地内存。<br>中断负载均衡：无论是软中断还是硬中断，它们的中断处理程序都可能会耗费大量的 CPU。开启 irqbalance 服务或者配置 smp_affinity，就可以把中断处理过程自动负载均衡到多个 CPU 上。</p>
<h3 id="补充判定"><a href="#补充判定" class="headerlink" title="补充判定"></a>补充判定</h3><ul>
<li>自愿上下文切换变多了，说明进程都在等待资源，有可能发生了 I/O 等其他问题；</li>
<li>非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢 CPU，说明 CPU 的确成了瓶颈；</li>
<li>中断次数变多了，说明 CPU 被中断处理程序占用，还需要通过查看 /proc/interrupts 文件来分析具体的中断类型。</li>
</ul>
<p>mpstat pidstat vmstat 联合判断是什么的性能瓶颈</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sk-xinye.github.io/2021/12/16/0-%E6%80%A7%E8%83%BD%E6%A6%82%E8%A7%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sk-xinye">
      <meta itemprop="description" content="愿所有努力都不被辜负">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sk-xinyeの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/16/0-%E6%80%A7%E8%83%BD%E6%A6%82%E8%A7%88/" class="post-title-link" itemprop="url">0.性能概览</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-16 16:42:27" itemprop="dateCreated datePublished" datetime="2021-12-16T16:42:27+08:00">2021-12-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-19 15:12:26" itemprop="dateModified" datetime="2021-12-19T15:12:26+08:00">2021-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="性能指标分析"><a href="#性能指标分析" class="headerlink" title="性能指标分析"></a>性能指标分析</h2><ul>
<li>选择指标评估应用程序和系统的性能</li>
<li>为应用程序和系统设置性能目标</li>
<li>进行性能基准测试</li>
<li>性能分析定位瓶颈</li>
<li>优化系统和应用程序</li>
<li>性能监控和告警</li>
</ul>
<img src="/2021/12/16/0-%E6%80%A7%E8%83%BD%E6%A6%82%E8%A7%88/%E6%80%A7%E8%83%BD%E8%A7%86%E8%A7%92.webp" class="">

<h2 id="linux-性能工具谱图"><a href="#linux-性能工具谱图" class="headerlink" title="linux 性能工具谱图"></a>linux 性能工具谱图</h2><img src="/2021/12/16/0-%E6%80%A7%E8%83%BD%E6%A6%82%E8%A7%88/linux%E6%80%A7%E8%83%BD%E5%B7%A5%E5%85%B7%E8%B0%B1%E5%9B%BE.webp" class="">

<h2 id="linux-性能优化脑图"><a href="#linux-性能优化脑图" class="headerlink" title="linux 性能优化脑图"></a>linux 性能优化脑图</h2><img src="/2021/12/16/0-%E6%80%A7%E8%83%BD%E6%A6%82%E8%A7%88/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%84%91%E5%9B%BE.png" class="">

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sk-xinye.github.io/2021/11/16/1-%E5%88%9D%E5%A7%8B%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sk-xinye">
      <meta itemprop="description" content="愿所有努力都不被辜负">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sk-xinyeの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/16/1-%E5%88%9D%E5%A7%8B%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">1.初始设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-16 13:51:48" itemprop="dateCreated datePublished" datetime="2021-11-16T13:51:48+08:00">2021-11-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-19 15:12:26" itemprop="dateModified" datetime="2021-12-19T15:12:26+08:00">2021-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">集群管理项目</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><h3 id="本次重构要解决问题"><a href="#本次重构要解决问题" class="headerlink" title="本次重构要解决问题"></a>本次重构要解决问题</h3><p>功能性问题：</p>
<ol>
<li><strong>特定节点</strong>上下线<strong>指定服务</strong></li>
<li>集群状态分发接口（目前第一次接入原有集群需要手动填写集群状态文件）</li>
<li>滚动升级</li>
</ol>
<p>代码问题：</p>
<ol>
<li>硬编码问题（提取到配置文件中）</li>
<li>各服务操作耦合问题（需重新定义接口，减少耦合，增加复用性）</li>
<li>模块边界问题（需重新定义模块）</li>
<li>日志问题</li>
</ol>
<h3 id="保存的元数据信息"><a href="#保存的元数据信息" class="headerlink" title="保存的元数据信息"></a>保存的元数据信息</h3><ol>
<li>当前集群状态{“kafka”:[ip1,ip2],”es”:[ip1,ip2,ip3],”current_ip”:”ip1”}</li>
<li>任务{“add_node”:{“kafka”:[“ip1”]},”status”:”finash”}</li>
</ol>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ol>
<li><p>增加节点</p>
<p>接收到命令{“kafka”:[ip1,ip2,ip3],”add_node”:{“kafka”:[ip3]},”current”：”ip”}<br>1.1 通过判断不是增加的节点，修改：服务配置文件，记录的两个文件<br>1.2 如果是增加节点，修改：修改上述3种文件并重启</p>
</li>
<li><p>减少节点</p>
<p> 接收到命令{“kafka”:[ip1,ip2],”remove_node”:{“kafka”:[ip3]},”current_ip”:”ip”}<br> 2.1比较参数，如果不是减少节点，修改：服务配置文件，记录的两个文件<br> 2.2如果是减少节点，修改上述3种文件并重启</p>
</li>
</ol>
<h3 id="模块设计"><a href="#模块设计" class="headerlink" title="模块设计"></a>模块设计</h3><ol>
<li>日志模块：用已有的</li>
<li>通信模块（api）：用已有的</li>
<li>manager模块：重新设计</li>
<li>配置文件模块：重新设计</li>
<li>做实际处理模块：修改</li>
<li>打包部署模块：重新设计</li>
</ol>
<h4 id="manager-模块设计"><a href="#manager-模块设计" class="headerlink" title="manager 模块设计"></a>manager 模块设计</h4><p>负责让不同节点启动不同服务</p>
<p>接收到的请求：{“cluster”:{“kafka”:[ip2],”zookeeper”:[ip1,ip2],”es”:[ip1,ip2]},”add_ip”:{“kafka”:[“ip2”]}}</p>
<p>all_ip = []</p>
<h4 id="数据目录"><a href="#数据目录" class="headerlink" title="数据目录"></a>数据目录</h4><p>\192.168.100.100\pbu\失准测试部\发布版本\新init包<br>\192.168.100.100\pbu\失准测试部\发布版本\A-7-1 失准项目（项目经理：帅金荣）\1-失准二期版本\V2.0.1版本\v2.0.1全量包（包含性能优化）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sk-xinye.github.io/2021/11/16/1-%E5%B9%B6%E5%8F%91%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sk-xinye">
      <meta itemprop="description" content="愿所有努力都不被辜负">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sk-xinyeの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/16/1-%E5%B9%B6%E5%8F%91%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">1.并发使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-16 10:30:53" itemprop="dateCreated datePublished" datetime="2021-11-16T10:30:53+08:00">2021-11-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-19 15:12:26" itemprop="dateModified" datetime="2021-12-19T15:12:26+08:00">2021-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="需要解决问题"><a href="#需要解决问题" class="headerlink" title="需要解决问题"></a>需要解决问题</h3><ul>
<li>自动调度线程</li>
<li>主线程可以获取某一个线程（或者任务的）的状态，以及返回值。</li>
<li>当一个线程完成的时候，主线程能够立即知道。</li>
<li>让多线程和多进程的编码接口一致</li>
</ul>
<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数times用来模拟网络请求的时间</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_html</span>(<span class="params">times</span>):</span></span><br><span class="line">    time.sleep(times)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;get page &#123;&#125;s finished&quot;</span>.<span class="built_in">format</span>(times))</span><br><span class="line">    <span class="keyword">return</span> times</span><br><span class="line"></span><br><span class="line">executor = ThreadPoolExecutor(max_workers=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 通过submit函数提交执行的函数到线程池中，submit函数立即返回，不阻塞</span></span><br><span class="line">task1 = executor.submit(get_html, (<span class="number">3</span>))</span><br><span class="line">task2 = executor.submit(get_html, (<span class="number">2</span>))</span><br><span class="line"><span class="comment"># done方法用于判定某个任务是否完成</span></span><br><span class="line"><span class="built_in">print</span>(task1.done())</span><br><span class="line"><span class="comment"># cancel方法用于取消某个任务,该任务没有放入线程池中才能取消成功</span></span><br><span class="line"><span class="built_in">print</span>(task2.cancel())</span><br><span class="line">time.sleep(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(task1.done())</span><br><span class="line"><span class="comment"># result方法可以获取task的执行结果</span></span><br><span class="line"><span class="built_in">print</span>(task1.result())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line"><span class="comment"># False  # 表明task1未执行完成</span></span><br><span class="line"><span class="comment"># False  # 表明task2取消失败，因为已经放入了线程池中</span></span><br><span class="line"><span class="comment"># get page 2s finished</span></span><br><span class="line"><span class="comment"># get page 3s finished</span></span><br><span class="line"><span class="comment"># True  # 由于在get page 3s finished之后才打印，所以此时task1必然完成了</span></span><br><span class="line"><span class="comment"># 3     # 得到task1的任务返回值</span></span><br></pre></td></tr></table></figure>

<ul>
<li>ThreadPoolExecutor构造实例的时候，传入max_workers参数来设置线程池中最多能同时运行的线程数目。</li>
<li>使用submit函数来提交线程需要执行的任务（函数名和参数）到线程池中，并返回该任务的句柄（类似于文件、画图），注意submit()不是阻塞的，而是立即返回。</li>
<li>通过submit函数返回的任务句柄，能够使用done()方法判断该任务是否结束。上面的例子可以看出，由于任务有2s的延时，在task1提交后立刻判断，task1还未完成，- 而在延时4s之后判断，task1就完成了。</li>
<li>使用cancel()方法可以取消提交的任务，如果任务已经在线程池中运行了，就取消不了。这个例子中，线程池的大小设置为2，任务已经在运行了，所以取消失败。如果- 改变线程池的大小为1，那么先提交的是task1，task2还在排队等候，这是时候就可以成功取消。</li>
<li>使用result()方法可以获取任务的返回值。查看内部代码，发现这个方法是阻塞的。</li>
</ul>
<h3 id="as-completed"><a href="#as-completed" class="headerlink" title="as_completed"></a>as_completed</h3><p>上面虽然提供了判断任务是否结束的方法，但是不能在主线程中一直判断啊。有时候我们是得知某个任务结束了，就去获取结果，而不是一直判断每个任务有没有结束。这是就可以使用as_completed方法一次取出所有任务的结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, as_completed, all_complete wait</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数times用来模拟网络请求的时间</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_html</span>(<span class="params">times</span>):</span></span><br><span class="line">    time.sleep(times)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;get page &#123;&#125;s finished&quot;</span>.<span class="built_in">format</span>(times))</span><br><span class="line">    <span class="keyword">return</span> times</span><br><span class="line"></span><br><span class="line">executor = ThreadPoolExecutor(max_workers=<span class="number">2</span>)</span><br><span class="line">urls = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>] <span class="comment"># 并不是真的url</span></span><br><span class="line">all_task = [executor.submit(get_html, (url)) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> future <span class="keyword">in</span> as_completed(all_task):</span><br><span class="line">    data = future.result()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;in main: get page &#123;&#125;s success&quot;</span>.<span class="built_in">format</span>(data))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line"><span class="comment"># get page 2s finished</span></span><br><span class="line"><span class="comment"># in main: get page 2s success</span></span><br><span class="line"><span class="comment"># get page 3s finished</span></span><br><span class="line"><span class="comment"># in main: get page 3s success</span></span><br><span class="line"><span class="comment"># get page 4s finished</span></span><br><span class="line"><span class="comment"># in main: get page 4s success</span></span><br></pre></td></tr></table></figure>

<p>as_completed()方法是一个生成器，在没有任务完成的时候，会阻塞，在有某个任务完成的时候，会yield这个任务，就能执行for循环下面的语句，然后继续阻塞住，循环到所有的任务结束。从结果也可以看出，先完成的任务会先通知主线程。</p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>除了上面的as_completed方法，还可以使用executor.map方法，但是有一点不同。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数times用来模拟网络请求的时间</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_html</span>(<span class="params">times</span>):</span></span><br><span class="line">    time.sleep(times)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;get page &#123;&#125;s finished&quot;</span>.<span class="built_in">format</span>(times))</span><br><span class="line">    <span class="keyword">return</span> times</span><br><span class="line"></span><br><span class="line">executor = ThreadPoolExecutor(max_workers=<span class="number">2</span>)</span><br><span class="line">urls = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>] <span class="comment"># 并不是真的url</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> executor.<span class="built_in">map</span>(get_html, urls):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;in main: get page &#123;&#125;s success&quot;</span>.<span class="built_in">format</span>(data))</span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line"><span class="comment"># get page 2s finished</span></span><br><span class="line"><span class="comment"># get page 3s finished</span></span><br><span class="line"><span class="comment"># in main: get page 3s success</span></span><br><span class="line"><span class="comment"># in main: get page 2s success</span></span><br><span class="line"><span class="comment"># get page 4s finished</span></span><br><span class="line"><span class="comment"># in main: get page 4s success</span></span><br></pre></td></tr></table></figure>

<p>使用map方法，无需提前使用submit方法，map方法与python标准库中的map含义相同，都是将序列中的每个元素都执行同一个函数。上面的代码就是对urls的每个元素都执行get_html函数，并分配各线程池。可以看到执行结果与上面的as_completed方法的结果不同，输出顺序和urls列表的顺序相同，就算2s的任务先执行完成，也会先打印出3s的任务先完成，再打印2s的任务完成</p>
<h3 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h3><p>wait方法可以让主线程阻塞，直到满足设定的要求。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, wait, ALL_COMPLETED, FIRST_COMPLETED</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数times用来模拟网络请求的时间</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_html</span>(<span class="params">times</span>):</span></span><br><span class="line">    time.sleep(times)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;get page &#123;&#125;s finished&quot;</span>.<span class="built_in">format</span>(times))</span><br><span class="line">    <span class="keyword">return</span> times</span><br><span class="line"></span><br><span class="line">executor = ThreadPoolExecutor(max_workers=<span class="number">2</span>)</span><br><span class="line">urls = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>] <span class="comment"># 并不是真的url</span></span><br><span class="line">all_task = [executor.submit(get_html, (url)) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">wait(all_task, return_when=ALL_COMPLETED)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;main&quot;</span>)</span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line"><span class="comment"># get page 2s finished</span></span><br><span class="line"><span class="comment"># get page 3s finished</span></span><br><span class="line"><span class="comment"># get page 4s finished</span></span><br><span class="line"><span class="comment"># main</span></span><br></pre></td></tr></table></figure>

<p>wait方法接收3个参数，等待的任务序列、超时时间以及等待条件。等待条件return_when默认为ALL_COMPLETED，表明要等待所有的任务都结束。可以看到运行结果中，确实是所有任务都完成了，主线程才打印出main。等待条件还可以设置为FIRST_COMPLETED，表示第一个任务完成就停止等待。</p>
<h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><h3 id="普通使用"><a href="#普通使用" class="headerlink" title="普通使用"></a>普通使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_html</span>(<span class="params">n</span>):</span></span><br><span class="line">    time.sleep(n)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;sub_progress success&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>: <span class="comment">#注意，在windows下这句话必须加！！！</span></span><br><span class="line">    progress = multiprocessing.Process(target=get_html, args=(<span class="number">2</span>,))</span><br><span class="line">    <span class="built_in">print</span>(progress.pid)</span><br><span class="line">    progress.start() <span class="comment"># 启动子进程</span></span><br><span class="line">    <span class="built_in">print</span>(progress.pid) <span class="comment"># 打印子进程的PID</span></span><br><span class="line">    progress.join() <span class="comment"># 等待子进程结束</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;main progress end&quot;</span>)</span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line"><span class="comment"># None</span></span><br><span class="line"><span class="comment"># 5444</span></span><br><span class="line"><span class="comment"># sub_progress success</span></span><br><span class="line"><span class="comment"># main progress end</span></span><br></pre></td></tr></table></figure>

<ul>
<li>multiprocessing.Process()传入执行入口函数和参数。</li>
<li>start()方法启动子进程。</li>
<li>progress.pid属性可以获取子进程的ID号，在未启动前，未None，启动后，得到系统分配的ID号。</li>
<li>join()方法等待子进程结束。</li>
</ul>
<h3 id="进程池1"><a href="#进程池1" class="headerlink" title="进程池1"></a>进程池1</h3><p>multiprocessing模块中提供Pool类来支持进程池编程。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_html</span>(<span class="params">n</span>):</span></span><br><span class="line">    time.sleep(n)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;sub_progress success&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>: <span class="comment">#注意，在windows下这句话必须加！！！</span></span><br><span class="line">    pool = multiprocessing.Pool(multiprocessing.cpu_count())</span><br><span class="line">    result = pool.apply_async(get_html, args=(<span class="number">3</span>,))</span><br><span class="line"></span><br><span class="line">    pool.close() <span class="comment"># 在join前必须运行close()</span></span><br><span class="line">    pool.join()</span><br><span class="line">    <span class="built_in">print</span>(result.get()) <span class="comment"># 得到子进程的返回值</span></span><br><span class="line"><span class="comment"># 执行结果  </span></span><br><span class="line"><span class="comment"># sub_progress success</span></span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用multiprocessing.Pool()来创建进程池，可以设置进程池的大小，默认为CPU的核心个数，一般进程也不会超过CPU的核心个数，超过了效率也不会高。</li>
<li>apply_async方法传入执行入口函数和参数，传入之后，就进入了子进程等待队列中，等待执行。返回值是ApplyResult对象，存储子进程的结果。</li>
<li>join()方法等待所有子进程的结束，调用前必须使用close()方法。</li>
<li>ApplyResult对象的get()方法，获取子进程的返回值。</li>
</ul>
<p>multiprocessing模块同样提供了类似于map的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_html</span>(<span class="params">n</span>):</span></span><br><span class="line">    time.sleep(n)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;s sub_progress success&quot;</span>.<span class="built_in">format</span>(n))</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>: <span class="comment">#注意，在windows下这句话必须加！！！</span></span><br><span class="line">    pool = multiprocessing.Pool(multiprocessing.cpu_count())</span><br><span class="line">    <span class="comment"># for result in pool.imap_unordered(get_html, [1, 3, 2]):</span></span><br><span class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> pool.imap(get_html, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>]):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;s sleep success&quot;</span>.<span class="built_in">format</span>(result))</span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line"><span class="comment"># 1s sub_progress success</span></span><br><span class="line"><span class="comment"># 1s sleep success</span></span><br><span class="line"><span class="comment"># 2s sub_progress success</span></span><br><span class="line"><span class="comment"># 3s sub_progress success</span></span><br><span class="line"><span class="comment"># 3s sleep success</span></span><br><span class="line"><span class="comment"># 2s sleep success</span></span><br></pre></td></tr></table></figure>

<ul>
<li>imap方法，结果输出顺序与传入的可迭代对象的顺序相同。</li>
<li>imap_unordered方法，结果输出顺序与子进程结束的时间顺序相同。</li>
</ul>
<h3 id="进程池2"><a href="#进程池2" class="headerlink" title="进程池2"></a>进程池2</h3><p>进程池的更好实现虽然multiprocessing模块中提供Pool类，但是使用进程池的时候，使用concurrent.futures模块中的ProcessPoolExecutor类更加方便。在介绍线程池的时候，介绍了ThreadPoolExecutor的使用，而ProcessPoolExecutor的接口实现和ThreadPoolExecutor完全一样，只用多创建多线程改完创建多进程即可。值得注意的是：在windows下进行多进程编程的时候，主程序一定要加if <strong>name</strong> == “<strong>main</strong>“:。</p>
<p>在CPU密集型操作时，使用多进程可以加快速度。<br>多进程API与多线程API基本相同，在使用线程池的时候，可以使用multiprocessing.Pool，也可以使用Future模块下的ProcessPoolExecutor，推荐后者。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/default-index/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/default-index/">1</a><a class="page-number" href="/default-index/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/default-index/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/default-index/page/15/">15</a><a class="extend next" rel="next" href="/default-index/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">sk-xinye</p>
  <div class="site-description" itemprop="description">愿所有努力都不被辜负</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">142</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sk-xinye</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
